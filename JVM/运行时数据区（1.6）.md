## 多线程共享数据区          
### 方法区      
作用：存储已经被虚拟机加载的类信息，常量，静态变量，方法字节码.class文件中的内容。  
GC在这里的动作：常量池回收，类型的卸载。           

### 堆(GC堆)           
作用：1，此内存区域存在的唯一目的是存储对象实例，几乎所有的对象实例都在这里分配。           
2，垃圾回收的主要场所。

#### 区域划分

- jdk7之前

  1，新生代内存

  2，老生代

  3，永生代

- jdk8及之后

  方法区也就是永久代被彻底移走了，取而代之的是元空间，元空间属于直接内存的一部分，元空间使用的是直接内存。

## 线程隔离区             
### VM stack       

主要保存局部变量，基本数据类型变量和堆内存中某个对象的引用变量。    

基本单位：栈帧，每个方法执行的时候都会在此处创建一个栈帧，用来存储局部变量表，操作数栈，方法出口(返回地址)等信息。 随着每个方法的执行，栈帧会进行入栈和出栈操作。     
局部变量表：实际上是一个栈结构，存放了编译器可知的各种基本数据类型，对象引用，returnAddress类型(指向一条字节码指令地址)。      对象引用可能指向一个对象的起始地址，也可可能是指向一个代表对象的句柄或者其他与此对象相关的位置。

常见的两种异常：          
1，StackOverflow 创建的栈帧数超过了虚拟机固定的栈深度。         
2，OutOfMemoryError 虚拟机可申请的内存空间不足。             
          
                  

### 本地方法栈         
作用:和虚拟机栈一样，在执行本地方法存放本地局部变量            
native接口：是Java提供的调用OS内核方法的接口，OS底层方法。在这个区域中也会出现Stack OverflowError和OutOfMemoryError错误



### 程序计数器           
当前线程正在执行的字节码的行号指示器。         
过程：字节码解释器JVM通过改变程序计数器的值来选取下一条执行的字节码指令，分支循环跳转异常处理线程恢复都依靠它。         
特点：逻辑上的计数器，每条线程之间的计数器相互独立，对java方法计数，native为undefined       

这也是内存区域在虚拟机规范中唯一一个没有规定任何oom的区域   

## 其他地方          
-  运行时常量池

  JDK1.7之前运行时常量池包含字符串常量池存放在方法区，此时hotspot虚拟机对于方法区的实现是永久代，jdk1.7的字符串常量池被移动到了堆当中，这里注意只有其中的字符串常量池被移动到了堆，运行时常量池剩下的东西还在方法区，也就是Hotspot的永久代，jdk1.8移除了永久代用元空间取而代之，这是字符串常量池依然在堆中，运行时常量池还在方法区，只不过方法区的实现变成了元空间。

  

- 直接内存：Java内存之外的本机内存，通过DirectByteBuilder对象操作外部内存如native对象所在的内存空间，避免java堆和native堆来回复制。           
  永久代：JDK 1.7之前对方法区的实现，1.7是堆内存，1.8使用元空间即本地内存来替代永久代。         
  元空间：1.8方法区的实现，使用本机直接内存，替代PermGen。解决永久代内存不足的问题。          