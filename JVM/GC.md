# 垃圾回收            

## 对象是否死亡 
```
1，引用计数法：每个对象都有一个引用计数器，当该对象被另一个对象引用时，计数器加一，若计数器为0，则是无效对象。        
优点：高效，执行受影响小。
缺点：无法解决对象支之间循环引用的问题，可能产生内存泄漏。       
2，可达性分析法，所用和GC Root直接或者间接相关得对象都是有效对象，即从对象开始往下走，处于引用链上的都是有效对象。       
优点：解决了第一种的缺点。       
2.1 什么是安全点？可达性分析过程中对象引用关系不会发生变化的快照点，所有线程进入安全点时，确保关系不变，垃圾回收才能进行。         
2.2 哪些是安全点？方法调用，循环跳转，异常跳转等。         
2.3 GCRoot对象都有哪几种：Java虚拟机栈（局部变量表，引用类型变量引用的对象），方法区中静态引用的对象，方法区常量引用的对象，本地方法栈引用的对象。        
```
## 回收无效对象，对象重生的过程
```
1，先进行可达性分析，对象若没有与GCRoot存在引用链连接，则对其标记进行第一次筛选           
2，若对象被判定为有必要执行finalize(finalize被覆盖且没有执行过finalize)，则将其放入F-queue队列，等待JVM 自动建立的Finalizer线程去执行，若无必要执行，则等待死亡。             
3，执行finalize后，若该对象和引用链上的对象相关联，则Finalizer线程对其第二次标记并移除队列，对象重生，否则回收。           
(finalize开销大且效率低，不宜手动调用)            
```
## 对象引用的种类         
```
强引用：直接new出的对象，程序启动永远不会回收。         
软引用：对象处于有用但不是必须存在的状态，适用于高速缓存，当OOM时引用对象回收。         
弱引用：每次GC运行，弱引用都会回收，适用于偶尔被使用且不影响垃圾收集的对象。           
虚引用：与没有引用没区别，无法通过引用知道它的属性，虚引用主要用于跟踪对象被垃圾回收的活动，且必须配合队列使用。          
```
## 判断方法区是否可被回收       
```
1，判断废弃变量，没有一个字符串的引用变量指向该字符串常量。          
2，判断无效的类：从加载器，class，实例三方面来讲，该类的所有实例都被回收，java堆中不存在它的实例；加载该类的类加载器已经被回收，该类对应的class对象没有在任何地方被引用。即无法在任何地方通过反射加载该类。         
```
## 垃圾回收算法        
### 标记清除      
从根开始扫描，判断并标记可回收对象，对堆内存进行线性扫描，清除所有被标记的对象           
缺点：产生大量碎片化空间，标记清除，两趟扫描，效率低下。          

### 复制算法       
将内存大小分为两个相等部分，同一时间只从一块移动到另外一块，A内存进行标记后，把A中的存活对象移动到B，清除A。          
解决问题：避免了碎片化空间，简单高效。       
存在的问题：浪费一半空间，存活率高的时候，效率低下。            

### 标记整理         
将所有可回收对象打上标记，让所有存活对象向前移动一段内存，覆盖可回收的区域，将最后一个可存活的边界之外的对象全部清除。         
优点：解决了碎片化的问题，不需要把内存拆分成两半，提高利用率，是一种老年代算法，因为老年代对象寿命长，GC会友大量存活，所以适合使用标记整理。         

### 分代        
不是一种具体的算法，而是一种内存分配思想，根据对象的存活周期的不同，将内存区分为老年代和新生代，对新生代使用复制算法，对老年代使用标记整理或者标记清除。          
                              
## 垃圾收集器           
### 新生代        
```
Serial：只开启一个GC线程来进行垃圾回收，回收时停止一切用户线程，易造成其他图形界面出现卡顿。不与其他线程交互，避免了开销，获得了单线程的最高利用率，适用于单CPU下client模式的虚拟机            
ParNew：Serial的多线程版本，同样需要停止一切用户线程，开启多个GC线程并行收集垃圾，默认线程数等于CPU核心数。多线程提高了垃圾回收的效率，单CPU环境下需要上下文切换，性能不如Serial，适合Server模式，另一方面。它也是除了Serial唯一能和CMS配合的收集器。       
ParallelScavenge 过程和ParNew一样，特点：比关注用户停顿时间的ParNew不同，它关注的是吞吐量(吞吐量=用户线程运行时间/(运行时间+垃圾回收时间)),更高的吞吐量意味着可以让更多用户访问应用，因此他也是server模式下的默认收集器。          
```
### 老年代       
```
Serial Old        
Parallel Old            
CMS(Concurrent Mark Swap)：     
步骤：      
1，初始标记，暂停全部线程STW，单线程标记与GCRoot直接关联的对象，过程很短。     
2，并发标记，进行GCRoot的追踪，标记所有关联对象，用户和GC线程并发执行。            
3，重新标记，暂停全部线程，重新标记并发阶段因为用户线程执行而使得标记产生变化的对象。       
4，并发清除，开启用户线程，同时GC线程进行垃圾清除，并发。                
特点：获得最短的用户线程停顿时间。标记清除算法                          
存在问题：采用标记清除，产生大量碎片。CMS对CPU敏感，若核心数比较低，则会占用很多资源，造成用户应用速度变慢。无法处理浮动垃圾，最终并发清除时，用户线程仍然在运行，
不可避免产生垃圾，正因此如此，不能等待内存快满再GC ，而要预留一块空间给用户装对象，若CMS执行还未完成时，预留空间不足，就会造成ConcurrentModelFailure从而开启另一次GC         
```
### G1
```
步骤：      
1，暂停全部线程，单线程标记和GCRoot直接关联的对象，然后与用户线程并发进行，从GCRoot找出存活对象，将因为用户线程发生变化的对象记录日志下来，暂停全部线程，然后将日志记录的对象去除放在Remembered Set中。
2，暂停全部线程，对每一个Region，通过对回收的价值和成本进行排序，再根据用户所期望的时间，制定回收计划，有限时间回收有限个region ，GC并行。                     
特点：并发和并行，分代收集，空间整合（标记整理算法）可预测停顿，每一个区域都有RememberedSet用来记录该Region的对象所引用的其他对象所在的Region区域，可达性分析时将这些区域加入GCRoot扫描，避免了整个堆的扫描。          
后台维护了优先队列，每次根据用户允许的回收时间，回收最有价值的Region。          
```

## 一个对象的一生             
### 内存容量分享            
```
1/3 新生代，其中（8/10 Eden，1/10 Survivor to，1/10 survivor from）         
2/3 老年代
```
### 新生代晋升老年代
```
首先新创建的对象会放在Eden中，当Eden满了的时候，启动一次MinorGC，对survivor1和Eden进行清除，没有GC的对象进入新的survivor1，即之前的survivor2            
1,eden 区满了，MinGC之后，如果survivor1空间仍然不足以放下剩余的存活对象，启动分配担保，将新生代的所有存活对象移动到老年代，新生代再放入Eden 
2，生命周期长的对象进入老年代，指经过多次MinorGC还存活的对象。       
3，大对象直接进入老年代，如占用一片连续空间的数组。（为了避免由于分配担保机制带来的复制而降低效率）
4，在Survivor区域中，相同年龄的对象大小总和超过了survivor内存一般的大小，则大于等于该年龄的对象进入老年代。
```
### 分配担保机制          
```
1，在MinorGC之前 ，虚拟机会检查老年代的是否存在一块连续的内存，其容量大于新生代所有对象的总和，若有，则直接进行MinorGC     
2，如果不是，先查看HandlerPromotionFailure是否为允许担保失败，若不被允许，则进行一次FullGC
3，若被允许，则查看历次晋升老年代对象大小的平均值，若老年代的连续内存大于该平均值，则进行MinorGC，否则FullGC     
```
### GC和担保发生的时机
```
分配担保：若survivor1区剩余内存仍然不足以承载MinorGC 后存活的对象，那么则分配担保机制将新生代对象放入老年代。     
触发MinorGC的条件：Eden装不下新对象时进行，将Eden区和survivor1区的对象移动到另一个survivor1区，GC后仍然存活的对象的年龄+1，若年龄超过阈值(默认15)，则对象进如老年代
触发FullGC的条件：1，老年代空间不足，无法为新对象分配空间，2老年代所有连续的闲置空间都不足以对新生代对象进行担保时，3MinorGC晋升到老年代对象的平均大小大于老年代剩余空间。4 MinorGC晋升到老年代对象的平均大小大于老年代的剩余空间，通过System.gc()来提醒JVM进行FullGC，但没有控制权 5 CMSGC出现PromotionFailed，Concurrent Mode Failure       
```

