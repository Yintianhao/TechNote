## 平台无关性         
```
Java源代码首先被编译为字节码，然后在不同平台的JVM进行解析，JVM执行字节码时将其转换为具体平台上的机器指令。
```
## Java程序运行过程
```
1，javac /path/className.java 先将.java编译为.class字节码文件
2，java className 执行该类的字节码文件
3，JVM识别.class文件，将其转换为对应操作系统可识别的机器码执行。
4，javap -c /path/class 可以看到反汇编的指令。
```
## 为什么不直接将java解析为机器码
```
1,class文件是经过检验过的结果，将Class文件转化为机器码不需要编译，而直接java源码，则每次都会编译，检查，浪费大量时间
2，抽象，面向接口编程，Class文件相当于接口，java源码相当于具体的类，机器码只知道.class文件这个接口，不知道具体的类，由此不仅是java代码，其他语言诸如Scala也可以被JVM转为机器码。
```
## 反射      
概念
```
将Java类中的字段，方法抽象成一个个对象，再将具体要使用的方法，字段通过类的实例对象invoke()绑定到这些映射对象上，即可动态使用实例对象的方法。
```
过程：     
```
1，通过反射，创建Class对象。
2，通过Class对象创建实例对象。
3，通过Class对象的API创建实例方法对象。
4，若方法或者字段是私有的，需要在Method对象设置setAccessible(true)。
5，将被调用方法的实例对象绑定在方法对象上。
```
## String
```
1，全都会在常量池创建。  
2，new String()都会在堆中创建。  
```
## String.intern()
```
1,new String("XXXX");当调用intern时，编译器会将字符串添加到常量池中，并且返回该常量的引用。
如果常量池中已经存在，则直接返回引用。
2，通过字面值赋值创建，会先在常量池查找是否存在相同的字符串，若存在，则将引用直接指向字符串，
若不存在，在常量池生成一个字符串，再将栈中的引用指向该字符串。
3，常量字符串"+"操作，编译阶段会直接合成一个字符串，如String str ="a"+"a";，则会直接合并成
String str = "aa";然后去常量池查找是否存在"aa"。从而决定创建或者引用。
4，对于final修饰的，编译器直接进行常量替换，而对于非final都是运行赋值处理。
5，常量字符串和变量拼接时，String str = str1+"aa;会调用StringBuilder.append()在堆上创建新对象。
6，版本变化：JDK 1.7之后，intern还是会先查询常量池，但是如果不存在，则不是将字符串拷贝到常量池，
而只是在常量池中生成原字符串的引用，简单地说就是这个对象的副本复制到常量池。

```
