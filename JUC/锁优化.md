## JDK1.6之后对于syn的优化
JDK1.6对锁进行了优化，锁主要有四种状态：无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态，他们会随着竞争的增大而升级，但是不能降级。这些锁的信息存储在MarkWord当中。
### 自旋锁         
自旋锁的思想是让一个线程在请求共享数据的锁时执行忙循环一段时间，如果在这段时间能获得锁，就避免了进入阻塞。但是自旋锁等待完全替代阻塞，因为自旋锁需要占用CPU，占用时间太长的话，反而不好，自旋等待的时间应该有限度，如果超过限定次数没有获得锁，就挂起线程，默认次数是十次。    
### 锁消除       
锁消除是指对于被检测出不可能存在竞争资源的锁进行消除，锁消除主要通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其他进程控制，那么就可以当做私有数据对待，也可以进行锁消除。从而避免无意义的请求锁的时间。
逃逸分析：https://blog.csdn.net/w372426096/article/details/80333657          
## 锁粗化      
如果一系列连续操作都是对同一个对象进行加锁释放锁，就会导致性能消耗，此时虚拟机会对锁的范围扩展到操作序列的外部。比如
```
for(int j =0;j < 100;j++){
            synchronized (Main.class){
                Object o = new Object();
            }
        }
```
经过优化为：      
```
synchronized (Main.class){
            for(int j =0;j < 100;j++){
                Object o = new Object();
            }
        }
```
## 偏向锁         
引入偏向锁的目的是为了在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，但是不同的是，轻量级锁在无竞争的情况下使用CAS来替代互斥量，而偏向锁在无竞争的情况下会把整个同步都消除掉。           
偏向锁思想是偏向于第一个获取锁对象的线程，第一次获取后CAS会将线程ID写入MarkWord，该线程获取之后再次获取锁对象时，就不需要进行任何同步操作，直到另一个线程获取锁，偏向状态结束，
撤销偏向之后恢复到未锁定或者轻量级锁。

## 轻量级锁        
轻量级锁的目的不是为了代替重量级锁，而是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量所带来的性能消耗，因为使用轻量级锁的时候，不会使用互斥量，而是采用CAS的操作。因为对于绝大部分锁，整个同步期间是不存在竞争的，所以并不需要互斥量来同步，可以采用CAS来同步，但是如果存在竞争，那么除了需要使用互斥量以外还需要额外的CAS操作，因为在有锁竞争的情况下，轻量级比重量级锁更慢。
过程：       
```
当尝试获取锁对象时，如果锁对象标记是未锁定(001)状态，此时VM在虚拟机栈中创建LockRecord，然后使用CAS操作将对象的MarkWord更新为LockRecord的指针，
如果CAS成功了，线程获取该对象上的锁，并且将对象点Mark Word的锁标记更新为00 代表轻量级锁状态。        
```

