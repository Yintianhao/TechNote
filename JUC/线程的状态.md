## 线程状态  
### 新建new         
创建后但是未启动。     
### 可运行Runnable       
正在Java虚拟机里运行，但是在操作系统中可能已经处于运行状态，也可能等待资源调度，资源调度完成即进入运行状态，即此状态表示可运行。        
### 阻塞Blocked       
请求获取monitor block从而进入synchronized部分，但是此时其他线程已经占用了monitor lock，要结束该状态进入Runnable需要占用monitor lock的线程释放。        
### 无限期等待WAITING        
等待其他线程显式唤醒，跟阻塞不同的地方是，阻塞是被动的，等待是主动的，通过wait()等方法可以进入。         
进入和退出的方法主要有：      
Object.wait()--->Object.notify()        
Thread.join()--->该线程执行结束        
LockSupport.park()--->LockSupport.unpark(Thread)        

### 限期等待TIME_WAITING      
无需等待其他线程唤醒，在一定的时间内会被系统自动唤醒。         
有以下几种方式：      
Thread.sleep()-->时间结束。        
设置时间的Object.wait()--->时间结束或者触发notify()        
设置了参数的Thread.join()--->时间结束/被调用的线程执行结束        
LockSupport.parkNanos()--->LockSupport.unpark(Thread)     
LockSupport.parkUntil()--->LockSupport.unpark(Thread)       
### 死亡TERMINATED     
线程执行结束/产生异常       

### Sleep和Wait的区别

Sleep，是Thread类的静态方法，将当前线程睡眠n毫秒，线程进入阻塞状态，当睡眠时间到了，会接触阻塞，进入可运行状态，等待cpu的到来，睡眠不释放锁。		

Wait，是object类的方法。必须和synchronized一起使用，线程进入阻塞状态，当notify或者notifyAll被调用后，会解除阻塞，但是只有重新占用互斥锁之后才会进入可运行的状态，睡眠的时候，会释放互斥锁。

### 常见的线程故障

- 死锁

  是最常见的一种线程故障，死锁的起因是多个线程之间互相等待对方而被永远暂停，死锁的产生必须满足四个必要条件：	

  1，资源互斥，一个资源每次只能被一个线程使用	

  2，请求和保持条件，一个线程因请求资源而阻塞的时候，对已经获得的资源保持不放。		

  3，不剥夺条件，线程已经获得的资源，在没有用完之前，不能强行剥夺。4，循环等待，若干线程之间形成一种首尾相接的循环等待关系。		

如何避免？

```
粗锁法，使用一个粗粒度的锁来清楚请求和保持条件，比如使用synchronized，缺点是会降低并发性能，并且导致资源的浪费。	
锁排序：指定锁的获取顺序，使用ReentrantLock的try方法来申请锁。
```

- 线程锁死

  线程锁死是指等待线程由于唤醒所需要的条件永远无法成立，导致其他线程无法唤醒这个线程而一直处于非运行的状态，导致其任务一直无法继续下去。

  一般分为两种：

  1，信号缺失锁死，是因为没有对应的通知线程来讲等待的线程唤醒，导致等待线程一直处于等待状态。

  2，嵌套监视器锁死，是由于嵌套锁导致等待线程无法被唤醒的一种故障，比如一个线程只释放内存的锁Y，但没有释放外层的锁X，但是通知线程必须先获得外层的X才能通过Y.notifyAll来唤醒等待线程。		

- 活锁

是指线程一直处于运行状态，但是所执行的任务没有任务的进展，比如一个线程总是在申请资源，但是一直没有申请成功。

- 线程饥饿

线程一直没有获得所需要的资源而导致线程一直无法运行的情况，线程调度模型分为公平和非公平，非公平调度模式下，这种情况比较大概率会出现。

