### AMQP

- 分层

ModuleLayer，协议的最高层，主要定义一些客户端调用的命令，客户端可以用这些命令来实现自己的业务逻辑。

SessionLayer，中间层，主要负责客户端命令发送给服务器，再将服务端应答返回给客户端，提供可靠同步机制和错误处理。

TransportLayer，最底层，主要传输二进制数据流，提供帧的处理，信道复用，错误检测和数据表示等等。

- 几大组件

交换器，消息代理服务器中用于把消息路由到队列的组件。

队列，用于存储消息的数据结构，位于硬盘或者内存中。

绑定，一套规则，告知交换器消息应该投递到哪个队列。

### RMQ的几个概念

- 生产者

投递消息的一方，消息一般分为消息体和标签。消费消息的时候，只会消费消息体。

- 消费者

接收消息的一方，连接到rmq，并订阅到队列上。

- broker服务节点

broker可以看做rmq的服务节点，一般情况下一个broker可以看做一个rmq服务器。

- queue

用于存储消息，多个消费者可以订阅一个队列，此时这个队列里的消息会被平摊给这些消费者处理。

- exchange

生产者发送消息给交换器，交换器将消息路由到一个或多个队列中。

- routingkey

生产者将消息发送到交换器的时候，会指定一个routingkey，用来指定这个消息的路由规则，这个routingkey需要和交换器类型和绑定键联合使用才有效。

- binding

通过绑定将交换器和队列关联起来，一般会指定一个bindingkey。

- exchange

fanout，所有发送到这个交换器的消息路由到和这个交换器绑定的队列中。

direct，把消息路由到bindingkey和routingkey完全匹配的队列中。

topic，主题类型，routingkey是一个由点号分开的字符串，bindingkey可以使用*和# 做模糊匹配

headers，基本用不到

### 生产者和消费者的基本工作流程

- 生产者

1，连接到broker，创建连接，开启一个信道。

2，申明一个交换器。

3，申明一个队列。

4，通过路由键把exchange和queue绑定起来。

5，发送消息，其中包含routingkey和exchange的消息。

6，相应的交换器根据和接收到的routingkey查找匹配的队列。

7，如果找到，将消息存入到相应的队列。

8，关闭信道。

9，管理连接。

- 消费者

1，连接到broker，创建连接，开启一个信道。

2，向broker请求消费响应的队列中消息，可能会设置相应的回调函数。

3，等待broker回应并投递相应队列中的消息，接收消息。

4，收到消息，ack。

5，rmq从队列里删除消息。

6，关闭信道。

7，关闭连接。

### 事务机制

channel.txSelect 用于将当前信道设置为事务模式。

channel.txCommit 用于提交事务。

channel.txRollback 用于事务回滚，如果在事务提交执行前由于rmq异常崩溃或者其他原因抛出异常，通过txRollback来回滚

### ack机制

生产者将信道设置为confirm模式，所有在该信道发布的消息都会被指定一个唯一的消息id，一旦消息被投递到所匹配的UI列的时候，rmq会发送一个确认给生产者，这样生产者就知道消息到达目的地了。

### 消费者如何拒绝消息

channel.basicNack

channel.basicReject

### 消息传输保证层级

at most once 最多一次，消息可能会丢失，但不会重复

at least once 最少一次，消息绝对不会丢失，但可能会重复传输

exactly one，恰好一次，每个消息只传输一次

### vhost

每个rmq服务器都能创建虚拟的消息服务器，也就是虚拟主机，默认为/

### 集群中的节点类型

内存节点，磁盘节点，rmq至少有一个磁盘节点。

### 消息的状态

alpha，消息内容和消息索引都存在内存中

beta，消息内容在磁盘，索引在内存

gamma，消息内容在磁盘，索引在磁盘和内存都有

delta，内容和索引都在磁盘中