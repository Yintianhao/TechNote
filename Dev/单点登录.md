## 单点登录

### 概念

在微服务的架构中，一个庞大的系统一般会进行拆分，拆分成为多个子系统，那么这就涉及到一个登录的问题，如果有AB两个服务，用户在A已经登录了，那么再去访问B的时候，就需要做到不再重新登录了。单点登录就是来解决这个问题的了，就是在多个系统中，用户只需要登录一次，各个系统即可感知这个用户已经登录。

### 单系统登录

单系统的流程：

```
1，登录，将用户信息存在Session对象中，如果Session对象中已经存在，说明已经登录。否则说明没有登录。
2，注销，从Session对象中删除用户的消息。
3，记住的功能，配合浏览器cookie来使用。
```

### 多系统登录

考虑从单系统到多系统会存在哪些问题。

- Session是不共享的

单系统中是用Session来保存用户的登录信息的，但多系统中每个服务可能对应有自己的Tomcat，而Session是依赖于当前服务的Tomcat，所以Session是不共享的。

- cookie跨域的问题

我们知道，浏览器访问一个域名的时候，带去的cookie只是这个域名的cookie，而不带别的域名的cookie，如访问www.A.com不会把www.B.com的cookie带给A域名，域名的不同，就会造成用户在访问A之后，再去访问B，原来的cookie用不上了。

那么上面的两个问题要怎么解决呢？			

对于Session不共享的问题，有

- Session复制，也就是说，Session在服务器之间进行复制，如Tomcat集群里进行Session同步。好处是这里不需要改动我们的代码，由Tomcat自己完成，但缺点也很明显，一是这样增加了网络传输，在实例比较多的情况下，延时也是一笔很大的开销，会影响集群性能。
- IP HASH的策略，可以通过Nginx来实现，来自于同一个ip的请求会访问同一个服务器，但是这样也不好，那就是这个服务如果挂了，那么就会丢失这部分的Session数据。并且这里负载均衡也变得没意义。
- 集中存储，比如放在一个redis集群里。

集中存储之后，将登录服务作为一个专门的服务，在子系统进行登陆的时候，请求登录服务，返回token，token在服务端被保存在redis中，并设置过期时间。其他系统登录的时候，如果之前的其他子系统的token没有过期，那么便返回这个token，下次请求的时候带上token，判断过期与否。

对于cookie跨域的问题，有

- 服务端将cookie写入response之后，客户端从cookie中取出token，在这之后，token以请求参数的形式访问别的域。
- 多个域名共享cookie，cookie的domain属性可以设置
- 将token保存在SessionStorage中，不依赖于Cookie了。

### Central Authorization Service

顾名思义，统一的认证中心服务。既然上面的跨域问题，我们没法将cookie给两个不同的域，那么将登陆都通过统一的域名来处理，不就可以避免这个问题的么，下面来举个例子。		

假设我公司现在有两个网站A，网站B，域名分别是www.A.com，www.B.com，统一认证中心的域名为www.cas.com。			

现在，用户想访问A中的某个资源，需要登录到B才能访问到，现在用户还没登录，所以A去请求认证中心，带上的参数为自己的域名www.A.com			

```
www.cas.com?domain=www.A.com
```

认证中心发现用户没登录，于是重定向到登录界面，用户完成登录，此时用户和认证中心建立一个全局的会话，会生成token，保存在客户端。注意这里是全局会话。		

用户登录之后，认证中心将页面重新定向到A，此时之前全局session的token会被带过去，拿到token的A再次请求认证中心，检测token是否有效。有效，那么A和这个用户建立一个局部的session，这里A和该用户都已经登录了。此时访问B的流程才刚刚开始：		

从A到B的时候，B检测到用户在它自己这里没有登录，于是重定向到认证中心，和之前一样，参数带上自己的域名。

```
www.cas.com?domain=www.B.com
```

此时用户使用的是同一个浏览器，并且访问的是同一个域名，那么前面A和认证中心建立全局session的时候保存的cookie派上了用场，于是认证中心发现已经和该用户建立会话了，那么不再继续生成token，而是重定向到B，带上该用户的token。

```
www.B.com?token=********
```

B拿着token再次请求认证中心，检测token是否有效，有效则与该用户建立局部会话。这一步过后，B和该用户也都已经登录了。