## JDK,JRE,JVM 
JDK,java Development Kit，jdk包含了完整的JRE，即Java运行时环境，此外还包含了许多其他的工具包。          
JRE，普通用户只需要安装JRE来运行Java程序，而开发人员必须安装jdk来编程，调试程序。         
JVM，JVM负责将字节码转为特定的机器代码，jvm提供内存管理和垃圾回收和安全机制等，独立于操作系统。         
区别和联系：            
JDK用于开发，JRE用于运行Java程序。          
JDK和JRE都包含JVM           
JVM是Java编程语言的核心。           

## 字节码
Java引入虚拟机，即在机器和程序之间加入一层虚拟的机器，在任何操作系统上都提供程序运行的接口，编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器将虚拟机代码转换为特定系统的机器机器码执行，然后在特定机器上运行。            
流程：      
Java代码--》编译器--》JVM可执行的字节码--》JVM--》JVM解释器--》机器码

## 字符型常量和字符串常量的区别
形式：字符型常量是单引号引起的一个字符，而字符串是双引号引起的若干个字符。            
含义：字符型常量相当于一个整型值，可以参加表达式运算，而字符串常量代表一个地址。        
内存大小：字符型只占两个字节，而字符串占若干个          

## 构造方法是否可以被重写
父类的私有属性和构造方法并不能继承，所以构造器也不能被重写，但是可以被重载。

## 重载和重写
重写：发生在父类和子类中，参数列表必须相同，返回值必须是父类对象中的返回类型或者其派生类。只有返回值不同不能称为重载，因为编译器根据方法名和参数无法确定具体调用的是哪个方法。
重载：发生在同一个类中，方法的名字必须相同，参数类型不同，个数不同，顺序不同。      

## 封装多态继承
封装：把一个对象属性私有化，同时提供给外界访问属性的接口。 减少耦合，隐藏细节，  保留特定的接口和外界联系，当内部发生变化的时候不影响调用方。
继承：使用已经存在的类作为基础新建类，新类定义可以增加新的数据和新的功能，也可以使用父类的功能，但不能选择性的继承父类。（子类可以拥有父类的非private的方法，子类可以拥有自己的方法即对父类进行扩展。）         
多态：指的是程序定义中引用变量所指向的具体类型和通过该引用发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用发出的方法调用到底是哪个类中实现的方法，必须在程序运行期才能决定。主要通过三种方式实现：通过子类对父类的覆盖来实现，通过在一个类对方法的重载来实现，通过将子类作为父类对象使用来实现。

## 继承     
1，不支持多继承。构造方法不可继承。如果构造函数是private修饰，那么这个类也不可继承。		

2，private,public,protected，不加三个权限符表示包级可见，类可见表示可以用这个类创建对象，成员可见表示其他类可以用这个类访问到类成员。       
protected表示子类可见，**子类的方法该方法的访问级别不允许低于父类的访问级别**。这是为了确保所有用到父类的地方都能用子类实例代替。       

3，Java类中的初始化顺序：父类静态成员变量和静态代码块->子类静态成员变量和静态代码块-->父类普通成员变量和代码块->父类的构造函数->子类的普通成员变量，代码块->子类的构造函数

## 抽象类和接口       
1，抽象类：使用abstract修饰的类，含有抽象方法的类一定是抽象类。      
抽象类和普通类的最大的区别就是抽象类不能被实例化，只能被继承。但是抽象类中允许有普通方法。                 
2，接口：接口是抽象类的延伸，Java8之前是一个完全抽象的类，之后，接口也可以支持默认的方法实现，因为不支持的话，接口维护成本太高。       
接口成员都是public，不允许private和protected，而抽象类没有这个限制。                
3，接口默认的字段都是static和final的，但是抽象类没有这个限制。                 
4，一个类可以实现多个接口，但是只能实现一个抽象类 ，也就是说抽象类只能单继承。     
5，从设计上来说，抽象是对类的抽象，是一种模板设计，但是接口实际上是对行为的抽象，是一种行为的规范。            

### 使用的选择  
使用接口：让不想关的类都实现一个方法，需要使用多重继承。        
使用抽象类：需要在多个相关的类中共享代码，需要能控制继承而来的成员的访问权限，需要继承非静态变量和非常量字段。         

## 基本类型    
byte(一个字节)，char(两个字节)，short(两个字节)，int(四个字节),float(四个字节),long(八个字节),double(八个字节),boolean(具体大小没有规定，编译器会将其转化为1/0)    

## 包装类型     
int -- Integer 等      
自动装箱和拆箱：      
装箱：基本类型-->包装类型    
拆箱：包装类型-->基本类型     

## 缓存池         
Integer.valueOf(123)和new Interger(123)的区别；      
前者取缓存池，后者直接新建对象。    
其他包装类型对应的缓存池：     
Boolean: true false      
Short -128->127     
Char \u0000-->\u007F      

## 元注解

- @Target

说明注解所修饰的对象范围

- @Retention

定义该注解被保留的时间长短，SOURCE 源文件中有效，CLASS Class文件中有效，RUNTIME 运行时有效

- @Documented

用于描述其他类型的注解应该被作为被标注的程序成员的公共API

- @Inherited

描述某个被标注的类型是被继承的，如果@Inherited修饰的注解类型被用于一个class，那么这个注解将被用于该class的子类

## String  
String是final类，不可继承。   
Java8中String内部使用char数组来存储。且char数组是final类型，所以String不可变。      
不可变有什么好处：？    
1，不可变的变量的Hash值不变， 常常用用作HashMap的key    
2，String池的需要，一个String对象如果已经被创建过了，那么就会从String池中引用，只有String是不可变的。才能使用String池      
3，安全性，String常作为参数，String不可变性可以保证参数不可变，      
4，线程安全，不可变性具有线程安全的特点，在多个线程中能安全使用。       
## String，StringBuffer，StringBuilder的区别        
String不可变，其他两个可变。（String类中的数组有final形容词修饰，而StringBuilder和StringBuffer的数组没有final修饰，所以是可变的） 

StringBuilder非线程安全，String和StringBuffer是线程安全的。StringBuffer内部使用synchronized同步           

性能方面，每次对String进行改变时，都会生成一个新的String对象，然后指向新的字符串对象，StringBuffer则是对内存本身进行操作，理论上StringBuilder比StringBuffer快一点。         
使用总结：少量数据->String          
单线程操作字符串缓冲区操作大数据->StringBuilder     
多线程操作字符串缓冲区操作大数据->StringBuffer      

## 字符串常量池   
保存着所有的字符串字面量，字面量在编译器确定，String.intern()可以将String加入常量池          
String a = "aaa";这种方式可以将aaa放入常量池，在Java7中常量池被放入堆中，如果过多使用会oom              
new String("aaaa");这个动作一共会创建两个字符串对象，aaaa是字符串字面量，因此编译器会创建一个字符串对象指向这个字面量，使用new的方式会在堆中创建一个字符串对象。        

## 参数传递      
Java参数传递是以值的形式来传入方法中，而不是引用传递。       

## final       
申明数据为常量，可以是编译时常量，也可以是运行时被初始化之后不能再被改变的常量。final修饰的基本类型不能被修改，修饰的引用类型引用不变，但是自身的内容可以修改。        
修饰的方法不能被重写，修饰类不能被继承。   

## static        
静态变量，类的所有实例对象都共享它，可以直接通过类名访问，它在内存中只存在着一份。          

相较于实例变量：实例变量，每创建一个实例就会产生一个实例变量。       

静态方法，在类加载的时候就存在了，不依赖于任何实例，所以他必须实现，不能是抽象方法，并且方法体中不能有this，super。      
静态语块：在类初始化时运行一次。      
静态内部类：非静态内部类需要先创建外部实例才能创建自己的实例，而静态内部类不需要。  


## super的使用     
访问父类构造函数，super()来调用特定的构造函数。       
访问父类的成员。        

## this 
this关键字用于引用当前类的实例。            

### this和super使用上的注意事项
this，super不能在static方法中用         
super调用父类的其他构造方法时，必须放在构造方法中的第一行，this调用本类的其他构造方法时也必须放在第一行

## 静态，非静态，实例变量，普通语句块的初始化顺序     
特点：静态变量和代码块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于先后顺序。最后才是构造函数的初始化         
继承时：        
父：静态变量，语句块。     
子：静态变量，语句块。     
父：普通变量，语句块。       
父：构造函数        
子：实例变量，语句块      
子：构造方法      

## Object的几个通用的方法      
### equals          
两个对象具有等价关系，必须满足：        
1，自反性：x.equals(x);        
2，对称性：x.equals(y)==y.equals(x)      
3，传递性：if(x.equals(y)&&y.equals(z)) x.equals(z)        
4，一致性：多次调用equals结果不变        
5，不是null的对象，调用equals均为false     

实现：     
检查是否是同一个对象的引用       
检查是否是同一个类型      
将Object对象进行转型(向上)，判断关键域是否相等。            

#### equals 和 ==
== 的作用是比较两个对象的地址。即判断两个对象是不是同一个对象，但是在基本的数据类型的情况下比较的是值，引用类型比较的是地址         
equals 的作用是比较两个对象是否相等。

### hashCode()            
返回哈希值，值得注意的是判断两个对象是否等价不能用hashCode，因为hash值具有随机性，两个不同的对象也可能有一样的哈希值        
HahsMap和HashSet都是hashCode来定位对象存储的位置，所以加入对象到这些容器中必须实现hashCode。   

#### 为什么会有hashCode()
在HashSet中，在压入数据时，会先计算对象hashcode，来判断对象加入的位置，同时也会与之前已经加入的数据的hashcode进行对比，如果没相同的则假设对象没有出现，如果发现了相同的hashcode，则比较对象的值是否相同，相同则不会插入成功，不同的话，就会散列到其他位置，这样其实就减少了equals的次数，提升了性能。           

#### hashCode和equals 
两个对象相等，则hashCode一定相同            
两个对象相等，对调用equals方法返回true          
若两个对象有相同的hashcode，两者也不一定相等        
所以equals如果被重写覆盖，那么hashCode函数也必须被覆盖。        

### toString()        
默认返回类名+后面的散列值的无符号16进制。        

### clone()       
是Obejct的一个protected的方法，如果不显示重写clone，其他类就不能直接调用clone方法。实现浅拷贝。      

#### 浅拷贝：       
指拷贝对象和原始对象的引用类型引用于同一个对象。        

#### 深拷贝：       
拷贝和原始对象的引用类型引用于不同对象           

#### clone的替代方案      
clone来拷贝即复杂并且可能抛出异常，还需要类型转换，尽量不要用，应该使用拷贝构造函数或者拷贝工厂来代替。        
          
