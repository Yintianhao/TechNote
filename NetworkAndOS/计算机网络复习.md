## 计算机网络

### OSI分层和TCPIP分层

- OSI体系结构

自上而下：应用层-表示层-会话层-运输层-网络层-数据链路层-物理层

- 五层协议

自上而下：应用层-运输层-网络层-数据链路层

- TCPIP体系结构

自上而下：应用层-运输层-网络层-网络接口层

### 分层介绍

- 应用层

通过应用进程间的交互来完成特定网络应用，应用层协议定义的是应用进程间的通信和交互的规则，这里的进程是指主机中运行的程序，对于不同的网络应用需要不同的应用层协议。比如域名系统DNS协议，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，应用层交互的数据单位成为报文。

- 运输层

运输层的主要任务是负责两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文，多个应用可以使用同一个运输层服务，由于一个主机可以同时运行多个线程，所以运输层有复用和分用的功能，复用就是指多个应用层进程同时使用运输层服务，分用是指运输层把收到的信息分别交付给上层的应用层进程。

- 网络层

网络层的任务时选择合适的网间路由和交换节点，确保数据能够及时传送，在发送数据的时候，网络层把运输层产生的报文或者用户数据报封装成分组和包进行传送，在TCPIP体系结构中，网络层使用了IP协议，因为分组也称为IP数据报。

- 数据链路层

数据链路层将网络层下来的IP数据报封装成帧，在两个相邻节点的链路上传送帧，每一帧包括数据和必要的控制信息，比如同步信息，地址信息，差错控制等。

- 物理层

在物理层上传输的数据单位是比特，物理层的作用是连接相邻计算机节点之间的比特流的透明传送，尽可能屏蔽调具体的传输介质和物理设备的差异，使得其数据链路层不必考虑网络的具体传输介质是什么，透明传送是指经过实际电路传送的比特流没有变化，对传送比特流来说，这个电路就好像看不见。

### 三次握手

过程：

```
第一次发送带有SYN标志的数据包
第二次发送带有SYNACK的标志的数据包
第三次发送带有ACK标志的数据包
```



- 为什么需要三次握手

目的是建立可靠的通信信道，双方确认对方的发送和接收都是正常的。

第一次握手：客户端什么都不能确认，但是服务端可以确认客户端发送正常，自己也接收正常

第二次握手：客户端确认自己发送正常，接收正常，对方接收正常，发送正常。服务端确认了对方发送正常，自己接收正常，

第三次握手：客户端确认自己发送正常，接收正常，对方接收正常，发送正常，服务端确认自己发送正常，接收正常，对方发送正常，接收正常。

- 为什么要传回SYN

接收端传回发送端的SYN是告诉发送端，我接收到的消息确实是你所发送的信号。

- 为什么要传送ACK

双方通信无误必须是两者互相发送消息都无误，传了SYN，证明发送端到接收端没有问题，但是接收端到发送端的通道还需要ack来验证。

### 四次挥手

过程

```
客户端发送一个FIN的信号，用来关闭客户端到服务端的数据传送
服务端接收到FIN，发回一个ACK信号，确认序号为收到的序号+1，和SYN一样，FIN需要占用一个序号。
服务端关闭与客户端的连接，发送一个FIN给客户端
客户端发回ACK报文确认，并将确认序号设置为收到的序号+1
```

- 为什么需要四次握手

任何一方都可以在数据传送结束之后发出连接释放的通知，待对方确认之后进入半关闭的状态，当另一方没有数据再传送的时候，则发出释放连接的通知，对方确认后完全关闭TCP连接。·

### TCP如何保证可靠传输

- 数据被分割为合适的数据块，TCP给发送的每一个数据包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
- 校验和，TCP保持首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化，如果校验和有差错，那么TCP会丢弃这个报文段和不确认收到此报文段。
- TCP的接收端会丢弃重复的数据
- 流量控制，滑动窗口协议。
- 拥塞控制，在网络发生拥塞的时候，减少数据的发送。
- ARQ协议，原理是每次发完一个分组之后，等待对方确认，在收到确认之后再发送下一个分组。
- 超时重传，在TCP发送一个段之后，会启动一个计时器，等待目的端收到这个报文段，如果不能及时地收到一个确认，将会重发这个报文段。

### ARQ协议

即自动重传协议，是OSI模型中数据链路层和传输层的错误纠正协议之一，它通过确认和超时两个机制，在不可靠的服务的基础上实现可靠的信息传输，如果发送方在发送一段时间之内没有收到确认帧，那么通常会重新发送，ARQ包括停止等待协议和连续发送ARQ协议。

- 停止等待ARQ协议

停止等待协议的基本原理是发送完一个分组就停止发送，等待对方确认，如果过了一段时间，还没有收到ack确认，说明没有发送成功，就需要重新发送，直到收到确认后再发送下一个分组。

在停止等待协议中，若接收方收到重复分组，就丢弃这个分组，但同时会发送确认。

优点：简单，缺点：信道利用率低，等待时间长。

出现差错的时候：超过一段时间没收到确认就重传前面的分组，因此每次发完一个分组就需要设置一个超时计时器，重传时间比数据在分组传输的平均往返时间稍微长一些，这就是自动重传请求ARQ。另外在停止等待协议中如果收到重复分组就会丢弃分组，但是会发送确认，连续ARQ协议对信道利用率进行了提高，维持一个发送窗口，凡发送窗口内的分组可以连续发送出去，而不需要对方确认，接收方采取累积确认，对按序到达的最后一个分组发送确认，表示这个分组位置的所有分组都正确收到了。

- 滑动窗口和流量控制

为了控制发送方的发送速率，保证接收方来得及接收，接收方发送的确认报文中的窗口字段可以用来控制发送窗口大小，从而影响发送方的发送速率。

- 拥塞控制的几个算法

1，慢开始，从小到大逐渐增大发送窗口，初始值为1，每经过一个传播轮次，就会加一次倍。

2，拥塞避免，到达一定的大小的时候，让拥塞窗口缓慢增大，每一个传播轮次大小+1

3，快重传和快恢复，它能够快速恢复丢失的数据包。如果一个接收机收到了一个不按顺序的数据段，那么会立即给发送机发送一个重复确认，如果发送机收到了三个重复确认，就会假定之前的数据段丢失了，然后立即重传这些丢失的数据段。

### 从输入URL到页面加载中间发生了什么

- DNS解析

首先查询本地域名服务器，如果没有找到，继续下面的步骤。

.->.com->google.com->www.google.com，直到本地域名服务器得到了google的ip地址并把它缓存到本地，供下次使用。

DNS缓存：浏览器缓存-系统缓存-路由器缓存-ips服务器缓存-根域名服务器缓存-顶级域名服务器缓存-主域名服务器缓存。

例如：Chrome缓存：chrome://dns/，系统缓存：/etc/hosts

DNS负载均衡：DNS每次访问的IP地址可能是不一样的，因为现在很多大型应用都不是单实例，并且DNS的目的只是找到一台能够处理请求的服务器就行，具体是哪台其实并不重要。

- TCP连接

HTTPS协议：HTTP报文是包裹在TCP报文中发送的，服务端收到TCP报文的时候会拆包提取出HTTP报文，但是这个过程中会有一定的风险，HTTP报文是明文传输的，如果中间被截取的话会存在信息泄露的风险。所以就有了HTTPS协议，在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密，从网络的层级结构来看他位于HTTP和TCP之间。

HTTPS的过程：HTTPS在传输数据之前需要客户端和服务器进行一次握手，在握手过程中将确立双方加密传输数据的密码信息，TLS/SSL使用非对称加密，对称加密以及hash等。

- HTTP请求

客户端构建HTTP请求报文，并通过TCP协议发送到服务器响应的端口。

请求报头：包含了客户端向服务器传递的请求附加信息和客户端自身的信息，常见的有Accept（指定客户端用于接收哪种类型的信息），Accept-Charset（字符集），Accept-Encoding（字符编码），Connection（设置为keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭tcp连接）

请求正文：当使用post put方法的时候，通常需要向服务端传递数据，这些数据就存储在请求正文中。

- 服务器处理请求然后返回http报文

后端从固定的端口接收到tcp报文，对tcp进行处理，解析http协议，并按照报文格式封装成http request对象，提供给上层使用。这一部分一般由Tomcat这样的web服务器完成。

响应报文：由三部分构成，分别是状态码，响应报头，响应报文。

状态码，响应报头就不多说了，响应报文一般存放数据，网页需要的html文件这些都在报文中。

- 浏览器解析渲染页面

这一部分属于前端的范畴了，就不深究了。

#### 各种协议和http的关系

HTTP协议的职责：生成针对目标web服务器的http请求报文

TCP协议的职责：将HTTP请求分割成报文段，按序号分成多个报文段，把每个报文段可靠地传递给对方。

IP协议的职责：搜索对方的地址，一遍中转一遍传送

TCP的职责：从对方接收到的报文段，重新组合报文段成报文。

HTTP的职责：对web服务器请求的内容的处理。

#### HTTP长连接短连接

HTTP1.0默认使用短连接，也就是客户端和服务端每做一次http交互，就建立一次连接，任务结束就中断。从1.1开始，默认使用长连接，使用长连接的http协议，响应头会加入：

```
Connection:keep-alive
```

但是他只是一个保持时间，并不代表永远不会关闭，HTTP的长短连接实质是TCP长短连接。

### HTTP是不保存状态的协议，如何保存用户状态

Session就是用来解决这个问题的，Session的主要作用是服务端用来记录用户的状态，服务端给特定的用户创建特定的Session用来表示这个用户并且跟踪这个用户。

Session一般使用内存和数据库来保存Session，那么客户端怎么来保存呢，对于浏览器端，那自然就是cookie。

那么cookie被禁用怎么办，既然客户端没法保存，那么把SessionId可以放在URL路径后面。

#### Cookie和Session的区别

Cookie一般用来保存用户信息，Session一般用来表示一个用户的状态。Cookie的数据保存在客户端，Session保存在服务端。

#### Http1.0 1.1的区别

- 长连接

HTTP1.0，默认使用短链接，网络开销比较大。1.1开始，默认使用长连接，默认开启Connection:keep-alive，1.1的持续连接有非流水线和流水线方式，流水线方式是客户端在收到HTTP的响应报文之前就能接着发送新的请求报文，非流水线方式是客户端只能先接收前一个响应之后才能发送下一个请求。通过Content-length来判断当前请求的数据是否已经全部接收，不允许同时有两个响应。

- 状态响应码

1.1中新增了24个错误响应码，比如409表示请求的资源和资源的当前状态发生了冲突。

- 缓存处理

1.1比1.0增加了更多的缓存控制策略

- 带宽优化及网络连接的使用

1.0中，存在着一些浪费带宽的现象，比如客户端只需要某个对象的一部分，而服务器却把整个对象送过去了，并且不支持断点续传，1.1在请求头里加入了range头域，只允许请求资源的某个部分，及返回码是206，这样就方便了开发者自由的选择以便于充分利用带宽和连接。



#### Http 2.0

2.0新增了二进制分帧，多路复用，头部压缩和服务器推送等功能。

### URL和URI

URL：统一资源定位符，可以提供一个资源的路径，是一种具体的URI，即URL既可以表示一个字段，也可以指明如何定位一个字段。

URI：统一资源标识符，可以唯一表示一个资源。

#### HTTP和HTTPS的区别

1，URL不同，端口不同

2，安全性和资源消耗，HTTP运行于TCP之上，所有的传输的内容都是明文，客户端和服务端都无法验证对方的身份，HTTPS是运行于SSL/TLS之上的HTTP协议，SSL/TLS运行于TCP之上，所有的传输内容都经过了加密，加密采用对称加密，当对称加密的秘钥用服务器放的证书进行了非对称加密，所有HTTP总体安全性没有HTTPS好，但是HTTPS比HTTP消耗更多的资源.

```
对称加密：密钥只有一个，加密解密都是同一个密码，并且加解密速度快，典型的对称加密有DES，AES等。
非对称加密：密钥成对出现，并且根据公钥无法推出私钥，根据私钥也无法推出公钥，加密解密使用不同的密钥，公钥加密需要私钥解密，私钥加密需要公钥解密，相对于对称加密速度较慢，典型的非对称加密算法有RSA，DSA等。
```

