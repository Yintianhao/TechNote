## ACK机制

### 业务层ACK机制

![avatar](D:\VsCodePro\TechNote\src\Image\ACK机制.jpg)

-  一次完整的推送流程

IM 服务器在推送消息时，携带一个标识 SID（安全标识符，类似 TCP 的 sequenceId），推送出消息后会将当前消息添加到“待 ACK 消息列表”，客户端 B 成功接收完消息后，会给 IM 服务器回一个业务层的 ACK 包，包中携带有本条接收消息的 SID，IM 服务器接收后，会从“待 ACK 消息列表”记录中删除此条消息，本次推送才算真正结束。

-  ACK机制中的消息重传

IM服务器的等待ACK的队列一般都维护一个计时器，一定时间内如果没有收到用户的ACK，那么就会从等待ACK的队列里取出消息进行重新推送。

- 消息重复推送的问题（去重机制）

服务端推送消息时携带一个 Sequence ID，Sequence ID 在本次连接会话中需要唯一，针对同一条重推的消息 Sequence ID 不变，接收方根据这个唯一的 Sequence ID 来进行业务层的去重，这样经过去重后，对于用户 B 来说，看到的还是接收到一条消息，不影响使用体验。





### 完整性检查

尽管有上面的ACK+超时重传+去重的组合拳，依然还是会有消息丢失的情况，比如服务器突然挂了，导致消息无法重传，那么这条消息就丢失了。针对这种情况，有如下补救措施。			

![avatar](../../Image/完整性检查.jpg)

```
IM 服务器给接收方 B 推送 msg1，顺便带上一个最新的时间戳 timestamp1，接收方 B 收到 msg1 后，更新本地最新消息的时间戳为 timestamp1。

IM 服务器推送第二条消息 msg2，带上一个当前最新的时间戳 timestamp2，msg2 在推送过程中由于某种原因接收方 B 和 IM 服务器连接断开，导致 msg2 没有成功送达到接收方 B。

用户 B 重新连上线，携带本地最新的时间戳 timestamp1，IM 服务器将用户 B 暂存的消息中时间戳大于 timestamp1 的所有消息返回给用户 B，其中就包括之前没有成功的 msg2。

用户 B 收到 msg2 后，更新本地最新消息的时间戳为 timestamp2。

通过上面的时间戳机制，用户 B 可以成功地让丢失的 msg2 进行补偿发送。
```

###  工程实现上保证时序可比较性

- 找一个标准的时间基准

实践证明，使用客户端的本地时钟或者产生的序号或者服务端的本地时钟或者序号作为时序基准都是存在一定的问题的，我们需要采用一个全局的序号生成器来实现一个时序基准，比如采用Redis的自增命令incr或者数据库的自增ID，当然也可以使用已知的算法，比如推特的SnowFlake算法。

- 时序基准的可用性

  使用Redis命令或者数据库的自增ID作为时序基准，都需要要求在主库上进行取号，那么势必会造成可用性的问题。出现一定的性能瓶颈。		

  使用SnowFlake算法得到的序号可能时间精度有限，一般能到秒级或者毫秒级，携带的消息采用的是服务器时间，也存在时钟不一致的问题。				

  而使用全局的序号生成器，虽然也避免不了时序上的误差，但是在用户层面几乎是无感知的。			

- 