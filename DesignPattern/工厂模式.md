## 工厂模式
就是在基类中定义一个创建对象的接口，让子类决定初始化什么类，工厂方法让一个类的实例化延迟到在子类中进行

### 分类
1，简单工厂，即静态工厂方法模式         
2，工厂方法模式，即多态性工厂模式或者虚拟构造子模式
3，抽象工厂模式，工具箱模式

### 为什么使用工厂模式
1，解耦，把对象的创建和使用过程分开         
2，降低代码重复，如果创建一个对象的过程很复杂，而且在许多地方会用到，就会有很多重复代码         
3，降低维护成本，由工统一管理，所以发生业务逻辑变化，不需要找到所有需要创建对象的地方逐一修改，只要在工厂修改即可， 

## 简单工厂模式
简单工厂模式严格来讲并不是23种常用的设计模式之一，只是工厂模式的一个特殊实现，简单工厂在实际的应用中相对于其他两个工厂模式比较少，适合简单的情况，并且简单工厂违背了开放-封闭原则，因为每次需要添加新的功能，都需要在switch语句中增加分支。

### 适用场景 
1，需要创建的对象比较少  
2，客户端不关心对象的创建过程       

### 简单工厂中的角色
1，工厂，是简单工厂模式的核心，负责实现创建所有实例的内部逻辑，工厂类可以被外界直接调用，创建所需的产品对象。               
2，抽象产品，简单工厂魔兽创建的所有对象的父类，负责描述所有创建的对象共有的公共的接口。         
3，具体产品，简单工厂模式的核心创建目标，所有的创建的对象都是充当这个角色的某一个实现类的实例。         
示例代码略          

### 使用反射机制实现简单工厂
这样可以避免简单工厂每次增加了新的产品类需要修改工厂类的弊端,Code包中有详细的代码示例           


## 工厂方法
简单来说就是在原有的Factory接口下，扩展出为特定的功能的新的Factory，比如一个计算器，加法有加法工厂，乘法有乘法工厂，针对不同的对象创建不同的工厂
### 适用场景
一个类不知道他所需要的对象的类，在工厂方法模式中，客户端不需要知道具体的产品类的类名，只需要知道对应的工厂即可，具体的产品对象有具体的工厂类创建，客户端需要知道的是具体的工厂类。
### 工厂方法中的角色
1，抽象工厂，是工厂方法的核心，他与应用程序无关，任何在模式中创建的对象的工厂类必须实现这接口。         
2，具体工厂，实现抽象工厂接口的具体的工厂类，包含与应用程序相关的逻辑，并且受到应用程序调用以创建某一种产品对象。           
3，抽象产品，工厂方法模式创建的对象的超类型，即所有产品的共同的父类或者共同拥有的接口。         
4，具体产品，实现了抽象产品的接口。         
如下：
```
public interface IFactory {
    Operation createOperation();
}
```
```
public class AddFactory implements IFactory{
    @Override
    public Operation createOperation() {
        return new OperationAdd();
    }
}
```
```
public class SubFactory implements IFactory {
    @Override
    public Operation createOperation() {
        return new OperationSub();
    }
}
```
main
```
public class Main {
    public static void main(String[] args){
        IFactory iFactory = new AddFactory();
        Operation add = iFactory.createOperation();
        System.out.println(add.getResult(1,1));
    }
}
```
简单工厂模式最大的优点在于工厂类包含了必要的逻辑判断，根据客户端输入的条件来选择性实例化对应的类，对于客户端来说，去除了对于具体产品的依赖，
但是，倘若在我们需要加入一些新功能，比如区域时，需要在工厂类的switch增加一个分支，而这违反了开放-封闭原则，而在工厂方法中，定义一个用于创建对象
的接口，让子类决定实例化哪一个类，工厂方法使得一个类的实例化延迟到其子类。

### 抽象工厂模式
抽象工厂是工厂方法的进一步深化。在这个模式下的工厂类不单单可以创建一种产品，而且可以创建一组产品。          
####  适用场景
1，和工厂方法一样客户端不需要知道它所创建的对象的类。      
2，需要一组对象共同完成某一个功能的时候，并且可能存在多组对象来完成不同的功能。         
3，系统结构稳定，不会频繁的增加对象。           
#### 角色
和工厂方法一样有四个角色，分别是抽象工厂，具体工厂，抽象产品，具体产品。不同的是具体产品，抽象工厂所创建的产品对象都是某一个具体产品类的实例，在抽象工厂中创建的产品属于同一个产品族，这不同于工厂模式中只创建单一的产品。          
#### 抽象工厂和工厂方法中的工厂有什么不同
抽象工厂是生产一整套产品的，这些产品之间有着关系和依赖，而工厂方法中的方法的工厂是生产单一产品的工厂。

#### 抽象工厂实例
Code包中
