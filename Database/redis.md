# Redis
## 1-数据类型
类型 | 可以存储的值 |  操作  
-|-|-
STRING | 字符串，整数，浮点数 | 对整个字符串或者字符串的一部分执行操作，对整数和浮点数执行自增或者自减操作 |
LIST | 列表 | 从两端压入或者弹出元素，对单个或者多个元素进行修剪，只保留一个范围内的元素 |
SET | 无序集合 | 添加，获取，移除单个元素。检查一个元素是否在集合中，计算交集，并集，差集，从集合中随机获取元素 |
HASH | 包含键值对的无序散列表 | 添加，获取，删除元素根据分值范围或者成员来获取元素计算一个键的排名 |
ZSET | 有序集合 | 添加，获取，删除元素，根据分值或者成员来获取元素计算一个键的排名 |

### SDS simple dynamic string 
在redis里面，C字符串只会作为字符串字面量用在一些无须对字符串的值进行修改的地方。     
```
redis> set msg "hello world"
```
1 键值对的键是一个字符串对象，底层的实现是一个保存了"msg"的sds        
2 键值对的值也是一个字符串对象，对象的底层实现是一个保存了字符串“hello world”的sds        
除此之外，sds还用于做缓冲区，例如AOF模块中的AOF缓冲区 ，客户端状态下的输入缓冲区。          
**sds定义:**
```
struct sdshdr{
  int len;//保存的字符串的长度，即buff中用了的字节数
  int free;//buff中还没有使用的字节数量
  char buff[];
}
```
#### SDS 和 C字符串的区别
```
1，**常数复杂度获取字符串的长度**。C字符串需要遍历字符串，而SDS的结构中有记录长度的len。
2，杜绝缓冲区溢出。C字符不记录自身长度带来的问题就是同意造成缓冲区溢出，而SDS不会
3，减少修改字符串时带来的内存重分配次数，C字符串在进行增长或者剪短时候需要对内存进行重分配，而实际上这是一个耗时操作，而在SDS中 ，由于SDS的长度和底层数组长度没有必然的关系，
数组中可以包含未使用的字节，通过这个未分配空间，采用了空间预分配(增长字符串)和惰性空间释放(缩短字符串)两种优化策略。
***空间预分配：***在对空间进行扩展时，会实现预留一部分额外的未使用空间。
***惰性空间释放：***在缩短时，不会立即将内存进行重分配，而是使用free的属性来将这些字节的数量记录下来，将来使用。
4，二进制安全：C字符串必须使用某种编码，并且字符串除了结尾之外字符串都不能包含字符的，否则最先被读入的空字符就会被认为是字符串结尾，只限制了C字符串只能保存文本数据，而不能保存图片音频等二进制数据，
而SDS的API是二进制安全的，所有的SDS API都会以处理二进制的方式来处理存放在buff数组里的数据。
5，兼容部分C字符串函数。
```
### 链表
Redis构建了自己的链表实现，最常用的就是list了，另外发布订阅，慢查询，监视器等功能都用到了链表。
```
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;
```
以及
```
typedef struct list {
    listNode *head;//头结点
    listNode *tail;//尾结点
    void *(*dup)(void *ptr);//节点值复制函数
    void (*free)(void *ptr);//节点值释放函数
    int (*match)(void *ptr, void *key);
    unsigned long len;//链表中所包含的结点数量
} list;
```
### 字典
字典在Redis应用非常广泛，redis数据库就是使用字典进行底层实现的。除此之外，哈希表也是hash键的底层实现执意。
#### 字典实现
字典使用哈希表来作为底层实现，一个哈希表里面可以有多个哈希表结点，而每个哈希表结点就保存了字典中的一个键值对。
```
typedef struct dictht {
    dictEntry **table;//哈希表数组
    unsigned long size;//哈希表大小
    unsigned long sizemask;//哈希表大小掩码，用户计算索引值
    unsigned long used;//已有的结点数量
} dictht;
```
表中结点的结构为
```
typedef struct dictEntry {
    void *key;//键
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;//值 三者之中其中一个类型
    struct dictEntry *next;//下一个结点
} dictEntry;
```
字典：
```
typedef struct dict {
    dictType *type;//保存操作特定类型键值对的操作
    void *privdata;/保存需要传给那些类型特定函数的可选参数
    dictht ht[2];//一般情况只用ht[0]，ht[1]在rehash的时候用
    long rehashidx; //记录rehash的进度
    unsigned long iterators; /* number of iterators currently running */
} dict;
```
#### 哈希算法
```
//1，使用dictType中的hashFunction来计算key的哈希值
hash = dict->type->hashFunction(key);
2，使用哈希表的sizemask属性和哈希值计算出索引值
index = hash & dict->ht[x].sizemax;//x = 0 or 1
```
#### rehash
在哈希表保存的键值逐渐增多或者减少时候，为了让哈希表的负载因子维持在一个合理的范围内，程序会对哈希表进行扩容或者收缩          
1 为字典中的ght[1]分配空间，这个哈希表空间大小取决于要执行的操作，以及ht[0]当前包含的键值对的数量。            
2 执行扩展操作，ht[1]的大小为第一个大于等于ht[0].used*2的二的N次方数。         
3 如果执行收缩，那么ht[1]的大小为第一个大于或者等于ht[0].used的二的N次方数。         
4 将保存在ht[0]中的所有键值对rehash到ht[1]上面，rehash指的是重新计算键的哈希值和索引值，然后将键值对放在ht[1]中指定的位置。        
5 当ht[0]包含的所有键值对都迁移到ht[1]后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]创建空白哈希表。       
#### 渐进式rehash
rehash并不是一次性，集中式的完成的，而是分多次，渐进式的完成，这样做是因为数据量比较大的情况下，rehash的过程会需要很大的计算量，而使得服务器在一段时间内暂停服务。         
**详细步骤**:       
```
为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表，在字典中维护一个索引计数器变量rehashidx，并将它的值设置为0，
表示rehash正式开始，在CRUD的过程中会将ht[0]哈希表中rehasidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后，
持续将rehashidx的值+1，最终到某个时间点上，ht[0]的所有键值对都迁移到ht[1]，rehashidx恢复为1，rehash完成。                
```

### 跳跃表
#### 介绍
```
跳跃表是一种有序数据结构，通过每个节点中维持多个指向其他节点的指针，从而达到快速访问其他节点的目的。
跳跃表支持平均O(logN)，最坏O(N)的节点查找，还可以通过顺序性操作来批量处理节点。大多数情况下效率甚至能和平衡树媲美。
并且实现上也比平衡树相对简单，Redis使用跳跃表来作为有序集合键的底层实现之一，如果一个有序集合元素数量很多，或者元素成员有比较
长的字符串的时候，redis就会使用跳跃表来作为有序集合底层实现。
```
#### 跳跃表结点
```
typedef struct zskiplistNode{
      struct zskiplistLevel{
           struct zskiplistNode forward;//前进指针
           unsigned int span;//跨度
      }level[];
      struct zskiplistNode *backward;//后退指针
      double score;//分值
      robj *obj;//成员对象
}zskiplistNode;
```
#### 层
level包含了许多个元素，每个元素都包含一个指向其他节点的指针，通过他们加快访问其他节点的速度，一般层越多访问的速度就越快。
每次创建一个新的节点之时，根据幂次定律（即越大的数出现的概率越小）随机生成一个介于1-32之间的数来作为level数组的大小。
#### 前进指针
每一层都有一个指向表尾方向的指针，用于从表头向表尾节点访问节点。
#### 跨度
用来记录两个节点之间的距离。(跨度越大距离越远，指向null的前进指针跨度为0)
#### 后退指针
用来从表尾向表头方向访问节点，值得注意的是每个节点只有一个后退指针。
#### 分值和成员
分值是一个double型的浮点数，obj是一个指针，指向字符串对象(保存SDS)      
### 跳跃表结构
依靠多个跳跃表结点就可以组成一个跳跃表，通过一个zskiplist的结构来持有这些结点则可以更方便对整个跳跃表进行处理。
```
typedef struct zskiplist{
      //指向表头和表尾
      struct zskiplistNode *header,*tail;
      //结点数量
      usigned long length;
      //层数最大的结点的层数
      int level;
}zskiplist;
```
### 整数集合
#### 介绍
用于保存整数值的集合抽象数据结构。可以保存int16_t，int32_t，int64_t的整数值，并保证不会重复。
```
typedef struct intset {
    uint32_t encoding;//编码
    uint32_t length;//元素数量
    int8_t contents[];//保存元素的数组
} intset;
```
编码的属性不同，数组中的每一项的能容许存入的最大的值也不同，这里不赘述。
### 升级
在添加新元素到整数数组里时，新元素的类型比整数集合现有的所有的元素类型都要长，就需要进行升级。       
步骤是：
```
1，根据新元素的类型，扩展整数集合底层数组的空间大小，并未新元素分配空间
2，将底层数组所有的元素都转换成与新的元素相同的类型，并将类型转换后的元素放置在正确的位置上，保持底层数组的有序性不变
3，新元素添加到底层数组中
```
#### 升级的好处
提高灵活性（可以将不同类型的整数放在同一个数据结构里面，在C语言中是不允许的），节约内存。
### 降级
整数数组不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

## 压缩列表
### 介绍
压缩列表(ziplist)是列表键和哈希键的底层实现之一，当一个链表键只包含少量列表项，并且列表项为小整数值或者长度比较短的字符串的时候，
Redis会使用压缩列表来作为列表键的底层实现。
### 压缩列表的构成
压缩列表是为了节约内存而开发的，是由系列特殊编码的连续内存组成的顺序型数据结构，一个压缩列表可以包含任意个节点，每个节点都保存一个字节数组或者一个整数值。
### 列表节点的构成
previous_entry_length
```
记录了压缩列表前一个节点的长度，因此当前节点的起始地址可以用来计算出前一个节点的起始地址。同时压缩表从表尾遍历到表头也是由它实现的。
```
encoding
```
记录了节点content所保存的数据的类型和长度
```
content
```
保存节点的值，可以使一个字节数组也可以是整数
```
### 连锁更新
在节点长度介于250到253字节之间时，并且前面插入一个大的结点时，需要进行内存重分配，这时候如果后面的结点长度也在250到253之间，就会被连锁更新。

## 对象
```
redis并没有直接使用前面的这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包括字符串对象，列表对象，哈希对象，集合对象以及有序集合对象这五种类型的对象。
```
### 对象的类型和编码
Redis使用对象来表示数据库的键和值，每次当我们在Redis的数据库中创建了一个键值对的时候。都至少都创建两个对象，一个对象用作键值对的键，另一个对象用键值对的值。
```
typedef struct redisObject{
    usigned type;
    usigned encoding;
    void *ptr;
}robj;
```
#### 类型
```
REDIS_STRING  字符串 
REDIS_LIST 列表对象
REDIS_HASH 哈希对象
REDIS_SET 集合对象
REDIS_ZSET 有序集合对象
```
//后续内容不赘述

## 服务器
### AOF，RDB和复制功能对过期键进行处理
生成RDB文件
```
在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件中，程序会对数据库中过期的键进行检查，已过期的键不会再保存在新的RDB文件中。
```
载入RDB文件
```
启动服务器时，如果开启了rdb的功能，那么服务器将对rdb文件进行载入
如果程序以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键就会载入到数据库中，过期的会忽略。
如果以从服务器的模式运行，那么文件中保存所有的键，不管过期或者未过期，都会被载入数据库中，但是主从服务器在进行数据同步的时候，
从数据库会被情空，所以过期键对rdb没有影响
```
AOF写入
```
当服务器以AOF模式运行时，如果数据库中某个键过期，但它没有被惰性删除或者定期删除，那么AOF不会因为这个过期键而产生任何印象。当过期键
背惰性删除或者定期删除，程序会向AOF 追加一条DEL命令，显式的来表示该键已经删除。
```
AOF重写 
```
在自行AOF 重写的过程中，程序会对数据库的键进行检查，已经过期的键不会保存到重写的AOF中
```
复制
```
主服务器在删除一个过期键之后，会显式地向所有服务器发送一个del命令，告知从服务器删除这个过期键，从服务器在执行客户端的读命令时，即使碰到了过期键也不会将其删除，而是继续像处理未过期的键一样来处理过期键。
从服务器只有在接到嘱咐其发来的del命令后，才会删除过期键
```
## RDB持久化
### RDB文件的创建和载入
有两个redis命令用于生成RDB文件，一个SAVE 一个BGSAVE ，SAVE命令会阻塞redis服务器进程，直到RDB创建完毕为止，在此期间服务器不处理其他请求。
BGSAVE会派生出一个子进程，然后子进程负责创建RDB文件，服务器进程继续处理请求。（redis启动会自动载入RDB文件，AOF更新频率通常比RDB更新频率高，所以优先载入AOF）服务器在载入RDB文件时，会一直处于阻塞状态直到载入完成。
### 自动间隔性保存
### RDB的文件结构
REDIS（五个字节，保存着redis五个字符，可以根据此来判断所载入的文件是否是RDB文件）+db_version（四字节，RDB的文件版本）+databases(零个或者多个数据库，以及各个数据库中的键值对数据)+EOF(一个字节，标志正文内容的结束)+check_sum（八字节，保存校验和，用来检查RDB文件是否有出错或者损坏）

### RDB总结
```
RDB用于保存和还原redis服务器所有数据库中的所有键值对数据        
SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器        
GBSCAVE不阻塞服务器         
服务器状态中会保存所有save选项设置的保存条件，当任意一个保存条件满足时，服务器会自动执行BGSAVE 
RDB是经过压缩的二进制文件，由多个部分组成
对于不同类型的键值对，RDB会使用不同的方式来存储。 
```

## AOF持久化
### AOF 文件
```
与RDB不同，AOF是通过保存redis写命令来记录数据库状态，被写入的所有的命令的格式都是以redis命令请求协议格式保存的，因为redis命令请求时纯文本协议，所以我们可以直接打开一个AOF文件 观察里面的内容。
```
### AOF持久化 的实现
```
命令追加-->文件写入-->文件同步
```
### 命令追加
执行完一个写命令之后，会以协议格式来将被执行的写命令追加到服务器状态的aof_buf的缓冲区的末尾。
### 写入和同步
服务器每次结束一个时间循环之前，会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区的内容写入AOF文件
**appendfsync**
```
always aof_buf所有内容全部写入并同步AOF
everysec 所有内容写入AOF， 如果上次同步AOF 文件的时间距离现在超过一秒，那么再次针对AOF进行同步，并且这个同步操作由一个线程专门负责执行。
no 所有内容加入AOF，但是不对文件同步，何时同步由操作系统决定。
```
### AOF重写
因为AOF随着写命令的增多体积也会变得很大，所以redis采用重写机制，会创建一个新的AOF文件 来替代现有的AOF文件 ，但是新的文件不会包含任何浪费空间的冗余命令，体积通常小很多。

