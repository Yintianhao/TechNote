# MYSQL逻辑架构     
## 第一层           
```
这一层的服务并不是MySQL独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构.
比如连接处理、授权认证、安全等等。
```
## 第二层
```
大多数MYSQL核心服务功能都在这一层，包括查询解析，优化，缓存以及所有的内置函数(日期，时间，数学和加密)，所有跨存储引擎
的功能都在这里实现：存储过程，触发器，视图
```
## 第三层         
```
包含了存储引擎，存储引擎负责MySQL数据的提取。服务器通过API与存储引擎通信，接口屏蔽了不同存储引擎之间的差异，存储引擎API 包括
很多个底层函数，用于执行诸如：开始一个事务或者根据主键提取一行记录等操作，但存储引擎不去解析SQL，出了innoDB会解析外键定义
不同存储引擎之间不会互相通信，只是简单地响应上层服务器的请求。
```
# 并发控制(共享锁，排他锁/读锁，写锁)        
## 读锁
读锁是共享的，多个用户可以在同一时刻读取同一个资源而互不干扰。
## 写锁
写锁是排他的，也就是一个写锁会阻塞其他写锁和读锁。

# 锁粒度
一种提高共享资源并发性的方式就是让锁对象更具有选择性，尽量只锁定需要修改部分数据，而不是所有资源，更理想的是
只对修改的数据锁定，任何时候，锁定的数据量越少，则系统的并发程序越高，只要相互之间不发生冲突。             
但是加锁的同时系统也会花费一定的性能来对锁进行管理，所以，所谓的锁粒度或者说锁策略就是在锁开销和数据安全性之间
寻求平衡，MySQL提高许多选择，每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。
# 表锁和表级锁
## 表锁
表锁是MySQL最基本的锁策略，而且是开销最小的策略，即对整个表上锁，一个用户对表进行CRUD时，首先需要获得写锁，阻塞其他
用户对表的读写操作，只有没有写锁时，其他用户才可以获得读锁。在特定的场景中，表锁有很好的性能，例如READLOCAL
表锁来支持某些类型的并发写操作。
## 行级锁 
可以最大程度支持并发处理，但同时也带来了最大的锁开销，在InnoDB和XTraDB都有实现行级锁，行级锁只在存储引擎中实现，
服务器层并没实现，服务器层完全不了解存储引擎的锁实现。
# 事务
事务就是一组**原子性**的SQL查询从，或者一个独立的工作单元，事务内的操作，要么全部执行成功，要么全部执行失败。
## 事例
```
START TRANSACTION;
SELECT * FROM student where Id=1605050212;
UPDATE student SET class=S2 WHERE Id=1605050212;
COMMIT;
```
# ACID 
## 原子性Atomicity
一个事务必须视为一个不可分割的最小工作单元，整个事务的所有操作要么提交成功，要么全部失败回滚。
## 一致性Consistency
数据库总是从一个一致性的状态转换到另一个一致性的状态。
## 隔离性 Isolation
通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。
## 持久性 Durability
一旦事务提交，则其所做的修改就会保存在数据库中，即使系统奔溃，修改的数据也不会丢失。
# 隔离级别 
较低的隔离级别可以执行更高的并发，系统的开销也更低。
## 未提交读(READ UNCOMMITED)
在这个级别中，事务的修改，即使没有提交，对其他事务也都是可见的，事务可以读取未提交的数据，即脏读。这一级别会导致许多问题，
从性能上它也不必其他好很多，但却缺乏其他级别的好处。一般很少使用
## 提交读(READ COMMITTED)
该级别中，一个事务开始时，只能看见已经提交的事务所做的修改，即一个事务从开始到提交之前，所做的任何修改都不会被其他事务看到。
这也是许多数据库默认的隔离级别，但MySQL不是
## 可重复读(REPEATABLE READ)
该级别保证在同一个事务中多次读取同样记录的结果是一致的，该级别解决了脏读的问题，但是理论上无法解决幻读的问题。
### 幻读
指的是某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入新的数据，当之前的数据再次读取该范围的记录，产生了幻行。
innoDB通过多版本并发控制(MVCC Multiversion Concurrency Control)解决了此问题。
## 可串行化(SERIALIZABLE)
该级别是最高的隔离级别，通过强制事务串行执行，避免了幻读问题，简单地说就是在每一行数据都加锁，所以可能导致大量的超时和锁争用
的问题，实际上很少用这个级别，只有在堆一致性要求很高而且可以接受没有并发的情况下才考虑。
| 隔离级别         | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| ---------------- | ---------- | ---------------- | ---------- | ------ |
| READ UNCOMMITTED | 是         | 是               | 是         | 否     |
| READ COMMITTED   | 否         | 是               | 是         | 否     |
| REPEATABLE READ  | 否         | 否               | 是         | 否     |
| SERIALIZABLE     | 否         | 否               | 否         | 是     |
# 死锁
死锁指两个或者多个事务在同一个资源相互占用，并请求锁定对方占用的资源。
当多个事务试图以不同的顺序锁定资源时，就可能产生死锁，多个事务同时锁定同一个资源时，也会产生死锁。     
为解决此问题，数据库实现了死锁检测和死锁超时机制。       
innoDB存储引擎能检测到死锁的循环依赖，并且立即返回一个错误，还有就是当查询的时间达到锁等待超时设定后放弃锁请求，innoDB目前解决死锁的办法是：将持有最少行级别排他锁的事务进行回滚。           
# Mysql中的事务
## 自动提交(AUTOCOMMIT)
MySQL默认采用自动提交模式，也就是说，如果不是显式开始一个事务，则每个查询都当做一个事务执行提交操作，可以通过AUTOCOMMIT变量来设置自动提交模式。当启用模式时，所有的查询都在一个事务中，直到显式的执行commit或者rollback回滚，该事务结束，同时开启新事务，修改AUTOCOMMIT对非事务型的表，不会有任何影响。
## 在事务中混合使用存储引擎
MySQL服务器层不管理事务，事务是由下层的存储引擎实现的，所以在同一个事务中，使用多种存储引擎是不可靠的。如果在事务中混合使用事务型的表和非事务型的表，在正常提交的情况下没有问题，但如果该事务需要回滚，非事务型的表上的变更就无法撤销，就会造成数据不一致的状态，事务最终的结果很难确定，因此每张表都应该选择合适的存储引擎。
# MVCC （乐观并发控制，悲观并发控制）
## innoDB的MVCC工作流程
在每一行记录后面保存两个隐藏列，一个保存行的创建时间，一个保存行的过期时间/删除时间，存储的不是实际的时间值，而是系统版本号，每开始一个新的事务，版本号就自动增加，事务开始时刻的系统版本号会作为事务的**版本号**，用来查询的每行记录的版本号进行比较

### 在REPEATABLEREAD的隔离级别下，MVCC的具体工作：
```
select 
InnoDB会根据以下两个条件检查每行记录，只有符合这两个条件的记录才能返回作为查询结果。
1，只查找早于当前事务版本的数据行，即行版本号小于等于事务版本号的行，这样可以确保事务读取的行，要么是在事务开始已经存在的，要么是事务自身插入或者修改过的。
2，insert InnoDB为新插入的每一行保存当前系统版本号作为行版本号。
3，delete innoDB为删除的每一行保存当前系统版本号作为删除标识。
4，update InnoDB为插入每一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行为作为删除标志。
```
保存两个额外的版本号，使得大多数读操作都不需要加锁。        
优点：性能很好，读取数据更简单，并且可以保证只会读取符号标准的行。           
缺点：每行记录都需要额外的存储空间，需要做更多行检查和额外的维护工作。         
MVCC指在重复读和提交读两个隔离级别下工作，其他级别和MVCC不兼容，因为未提交读总是会读取最新的数据行， 而不是符合当前事务版本的数据行，而串行化都需要加锁。           
# MySQL的存储引擎
## InnoDB存储引擎
是MySQL的默认存储引擎，也是使用最广泛的存储引擎，InnoDB被设计来处理大量短期事务，短期事务大部分情况是正常提交的，少数会被回滚。           
1，数据存储都在表空间里          
表空间里由一系列的数据文件组成，在MySQL4.1之前，InnoDB可以将每个表的数据和索引存储在单独的文件里     
2，采用MVCC来支持高并发，并且实现了四个标准的隔离级别。        
默认的级别是可重复读，并且通过间隙锁策略防止幻读的出现，间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中间隙进行锁定，防止幻读行的插入。           
3，基于聚簇索引建立。
聚簇索引对主键索引有很高的性能，不过他的二级索引中必须包含主键列，如果主键列很大的话，其他的所有索引都会很大，因此，若表上的索引比较多的话，主键应当尽可能的小。        
4，InnoDB内部的许多优化
a，从磁盘读取数据时采用的可预测预读，能够从内存中建立hash索引来加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区。     
5，作为事务型的存储引擎，InnoDB通过一些机制和工具支持热备份。          
MySQL的其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，在读写混合场景中，停止写入也意味着停止读取。     
## MyISAM 存储引擎        
5.1之前的版本是MySQL的默认存储引擎，MyISAM提供了很多的特性：全文索引，压缩，空间函数，但MyISAM不支持事务和行级锁，且崩溃后无法恢复。        
1，表存储在数据文件和索引文件两个文件中。
MyISAM表可以动态或者静态行，MySQL会根据表的定义来决定采用何种行格式，MyISAM表可以存储的行记录数，受限于可用的磁盘空间或者操作系统单个文件的最大尺寸。           
2，MyISAM对整张表加锁，而不是针对行         
3，MyISAM可以手工或者自动检查或者修复操作。
4，即使是BLOB，TEXT 大字段，也可以基于前500个字符建立索引，支持全文索引。         
5，支持延迟更新索引键             
# 数据类型
## 整数
```
1 tinyint 8
2 smallint 16
3 mediumint 24
4 int 32
5 bigint 64
```
值得一说的是，实际上MySQL制定整数宽度，如int(11)，实际上对于大多数应用没有意义：因为MySQL不会限制值的合法范围，只是规定了MySQL一些交互工具如命令行客户端来显示字符的个数，对于存储和计算来说，int(1)和int(20)是相同的。
## 实数类型    
```
float 4
double 8
decimal 存储精确的小数
```
浮点和decimal类型都可以指定精度，对于decimal列，可以指定小数点前所允许的最大位数。
## 字符串类型
```
1 varchar 可变长字符串，比定长更节省空间，但由于行是变长的，在update时可能会比原来更长。
适应以下：
字符串的最大长度比平均长度大很多
列更新少
使用了utf8复杂的编码，每个字符都使用不同的字节数来存储
```
```
2 char 定长字符串，存储时会删除所有的末尾空格，char值会根据需要采用空格来填充比较
存很短的字符串或者所有的值都接近同一个长度
经常变更的数据，char比varchar能产生更少的碎片
对于非常短的列，char比varchar更省空间，因为varchar需要额外的字节来存储字符串长度
```
```
3 binary varbinary存储二进制字符串，存储的是字节码而不是字符，使用\0来填充而不是空格
```
```
4 blob 用来存储很大的数据，采用二进制存储，没有排序规则和字符集
```
```
5 text 存储大数据，但是是采用字符形式
```
```
6 enum 把一些不重复字符串存储成一个预定的集合
```
## 时间和日期
```
datetime 占八个字节，可以存储从1001到9999的日期和时间，精度为秒，把日期封装成YYYYMMHHMMSS的整数中，和时区无关。
```
```
timestamp 保存从19700101到至今的秒数，占四个字节，到2038为止，依赖于时区。
```
## 位类型
```
bit 
set
```
# 索引
索引是存储引擎为了快速找到记录而设计的数据结构。        
例如
```
select name from student where id = 1;
```
如果id列上有索引，那么MySQL就会使用该索引找到id为5的行          
在MySQL中，索引是在存储引擎而不是在服务器层实现的，没有统一的索引标准，不同存储引擎的索引实现方式也不尽相同，也不是所有的存储引擎都支持所有类型的索引。        
## 索引的作用
大大减少了服务器需要扫描的数据量
帮助服务器避免排序和临时表
## MySQL支持的索引类型     
### B+Tree 索引
是大多数MySQL存储引擎默认的索引类型，因为不需要进行全表扫描，只需要对树搜索，所以查找速度快很多。因为b+Tree的有序性，所以除了用于查找，还可以用于排序和分组。同样也可以指定多个列作为索引列，多个索引共同组成键，适用于全键值，键值范围和左键前缀查找，如果不是按索引列查找，则无法使用索引。          
B+Tree索引分为主索引和辅助索引，主索引的叶子结点data域记录着完整的数据记录，这种索引方式称之为聚簇索引。辅助索引的叶子结点的data域记录着主键的值，因此在使用辅助索引进行查找时，需要先查到主键值，然后再到主索引中进行查找。
### 哈希索引
基于哈希表实现。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希索引将所有的哈希码都存储在索引中，同时在哈希表中保存指向每一个数据行的指针。         
优点：查找速度快 O(1)
缺点：               
1无法用于排序，因为哈希索引存储的是哈希码         
2只支持精确查找，不支持范围查找和索引列匹配查询          
3无法避免哈希冲突，维护索引的代价高          
### 自适应哈希索引         
当某些哈希值使用频繁时，会在内存中基于B+Tree索引之上再创建一个哈希索引，这样B+Tree索引页具有哈希值的一些优点。
### 全文索引
全文索引查找的是文本中的关键词，而不是直接比较索引中的值，全文索引和其他积累索引的匹配方式不一样，全文索引类似于搜索引擎，而不是简单地where查询，使用的是match against，全文索引使用倒排索引来实现，记录着关键词到其所在文档的映射，InnoDB在MySQL5.6.4版本中也支持了全文索引。          
### 空间索引        
MyISAM支持空间索引，可以用于存储地理坐标，和B+Tree不同，空间索引无需采用前缀查询，空间索引会从所有维度来索引数据，可以有效的使用任意维度来组合查询。          
缺点：必须使用MySQL的GIS函数来维护数据，而MySQLGIS支持不完善，所以一般不使用。         
## 高性能索引策略
### 独立的列      
查询时索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用已有的索引。       
如
```
select act_id from sakila.actor whee act_id + 1= 5;
```
### 前缀索引和索引选择性
选择足够长的前缀来保证较高的选择性，同时不能太长（节省索引空间），对于blob，text等很长的数据类型来说，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。
### 多列索引
在需要多个列作为条件查询时，使用多列索引比使用单列索引性能更加好，如
```
select film_id,actor_id from sakila.film_actor where actor_id=1 and film_id=1;
```
在MySQL5.0+的版本中引入了索引合并的策略，一定程度上可以使得表上的多个单列索引来定位指定的行，这是一种优化策略，但如果MySQL为你的查询使用了这个策略，更多时候说明你的表索引建的不好。
### 选择合适的索引列顺序
正确的顺序是依赖于使用该索引的查询，并同时需要更好的满足排序和分组的需要，当不需要排序和分组时，将选择性更高的放在前面是是最好的。
（选择性是指不重复的索引值和记录总数的比值，最大值为1此时每个记录数是唯一的，选择性越高，每个记录区分度越高，查询效率也更高）
### 聚簇索引
并不是单独的索引类型，而是一种数据存储方式，具体的细节依赖于其实现方式，InnoDB的聚簇索引实际上是在同一个结构中保存了B+Tree索引和数据行，它的数据实际上存放在正在索引的叶子页里面，聚簇指的是数据行和相邻的键值紧凑的存储在一起。
#### 一个表只能有一个聚簇索引
因为无法将数据行存在两个不同的地方，InnoDB通过主键聚集数据，也就是被索引的列就是主键列，如果没有定义主键，则挑选唯一的非空索引来代替，若没有这样的索引，InnoDB会隐式的定义一个主键，作为聚簇索引，InnoDB值聚集统一和页面的记录，包含相邻键值的页面可能会相距甚远。
**优点**：               
1，可以将相关数据保存在一起，例如实现邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件，如果没有使用聚簇索引，则每封邮件都可能访问一次磁盘。           
2，数据访问更快。           
3，使用覆盖索引扫描的查询可以直接使用叶结点的主键值。         
**缺点**：           
1，聚簇索引最大限度的提高了IO密集型应用的性能，但如果数据都放在内存中，聚簇索引就没有那么多优势了。       
2，插入速度严重依赖于插入顺序。            
3，更新聚簇索引的代价很高，因为会强制将每个更新的行，移动到新的位置。           
4，可能面临页分裂的问题，页分裂会导致表占用更多的磁盘空间，在插入新的行或者主键时，若行的主键值要求必须将这一行插入到某一个已满的页面内。此时就会将页面分为两个来容纳这一行。           
5，聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。          
6，二级索引可能比想象的大，因为二级索引的叶结点包含了引用行的主键值。       
7，二级索引访问需要两次索引检查，而不是一次。         
### 覆盖索引
如果一个索引包含或者覆盖所有需要查询的字段的值，称之为覆盖索引，因为查询只需扫描索引而无需回表。          
**优点**：         
1，索引条目远远小于数据行大小，可以极大地减少数据访问量。         
2，更少的IO，因为索引是按照列值进行存储，所以对于IO密集型的范围查询会比随机从磁盘读取一行的IO要少得多。       
3，一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用，这样狐疑造成严重的性能问题，使用覆盖索引可以避免这个问题。          
4，由于InnoDB的聚簇索引，覆盖索引对于InnoDB特别有用，InnoDB的二级索引中的叶子结点保存行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引二次查询。          
### 前缀压缩索引
MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能，默认只压缩字符串，但可以通过参数设置对整数进行压缩，压缩的方法：先完全保存索引快中的第一个值，然后把其他值和第一个值进行比较得到相同前缀的字节数和剩余不同后缀部分，把这部分存储。          
### 避免冗余和重复索引
重复索引：指在相同的列上按照相同的顺序创建相同类型的索引。       
冗余索引：如果创建了(A,B)，那么创建(A)就是冗余索引，因为它是前一个的最左前缀索引，因此(A,B)可以当做(A)使用，但是(B,A)就不能算冗余索引。          
冗余索引通常发生在为表添加新索引的时候，列入有人为新的索引(A,B)而不是扩展已经有的索引，还有一种情况就是将一个索引扩展为(A,D)，其中ID是主键，对于InnoDB来说主键列已经包含在二级索引中了。       

## MySQL查询过程        
### 查询路径
```
1 客户端发送一条查询给服务器。
2 服务器先检查查询缓存，命中缓存那么直接返回，否则进入下一阶段  
3 服务器对SQL进行解析，预处理，再由优化器生成响应的执行计划。 
4 MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询，
5 将结果返回
```
### 通信协议
客户端和服务器采用半双工通信，这意味着在任何时刻要么是由服务器向客户端发送数据，要么由客户端向服务器发送数据。两者不可能同时发送。       
这样的好处是使得MySQL通信简单快捷。      
缺点是无法进行流量控制：一端一旦开始发送数据，那么另一端只有接收完整的消息后才能响应，当查询语句太长时，就可造成服务器会拒绝接收更多数据抛出错误。客户端就只能等待了。这就是为什么max_allowed_packet和limit特别重要的原因。
### MySQL查询状态
```
sleep 线程正在等待客户端发送新的请求
query 线程正在执行查询或者正在将结果发送给客户端
locked 在MySQL服务层，该线程正在等待行表锁，在存储引擎级别实现的锁。
analyzing and statistics 线程正在收集存储引擎的统计信息，并生成查询的执行计划。
coping to tmp table 线程正在执行查询，并将结果复制到一个临时表中。(group by或者文件排序或者union操作)
sorting result 对结果进行排序
sending data 多种情况：在多个状态中传送数据，或者生产结果集，或者向客户端返回数据。
```
## 切分
### 水平切分
又称sharding，是指将同一个表的记录拆分到多个相同结构的表中。当一个表的数据不断增多时，切分是必然的选择，它可以将数据分布到集群的不同结点上，从而缓存单个数据库的压力。       
### 垂直切分
垂直切分是将一张表切分成多个表，通常是按照列的关系秘籍程度进行切分，也可以利用垂直切分将被使用的列和不经常使用的列切分到不同的表中，在数据库层面使用垂直切分将按数据库的表密集程度部署到不同的库中，例如以下电商网站将数据库分为商品库和用户数据库一样。
### 水平切分策略
1，哈希取模          
2，范围，ID 范围或者时间范围          
3，映射表，使用单独的一个数据库来存储映射关系。          
### 水平切分存在的问题
#### 事务问题
使用分布式事务来解决。
#### 连接
可以将原来的连接分解为多个单表连接，然后在用户程序中进行连接。
#### ID唯一性
使用全局唯一ID      
为每个分片制定一个ID范围         
分布式ID生成器          
##  复制
### 主从复制
只要涉及三个线程：binlog,I/O线程，SQL线程       
binlog：负责将主服务器上的数据更改写入二进制日志(binlog)中      
I/O：从主服务器上读取二进制日志，并写入服务器的中继日志(relay log)      
SQL线程：读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放。       
### 读写分离（一般采用代理来实现）
主服务器处理写操作以及实时性要求高的操作，从服务器负责读操作      
读写分离能提高性能的原因：       
1 主从服务器负责各自的读和写。极大程度上缓解了锁的争用。       
2 从服务器可以使用MyISAM，提升查询性能以及节约系统开销     
3 减少冗余，提高可用性。
