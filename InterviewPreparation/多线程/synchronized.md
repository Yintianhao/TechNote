## Synchronized

- 被锁的对象

  - 普通方法

    锁当前实例对象。

  - 静态同步方法

    锁的是class对象

  - 方法块

    锁的实际括号里的对象

- 内部细节

  使用monitorexit和monitorenter指令，简单提一下这两个命令，monitorenter是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束的位置和异常的位置，JVM要保证每一个monitorenter有对应的monitorexit匹配，任何对象都有monitor和自己关联，当一个monitor被持有的时候，进入锁定状态，线程执行到monitorenter的指令的时候，将会尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁。

  - 对象头

    synchronized用的锁是存在对象头里的，占两个或者三个字宽，对象头里存储对象的hashCode，分代年龄和锁标记位。在运行期间，这些数据会随着锁标志位的变化而变化。锁标志位有四种分别对应轻量级锁，无锁，偏向锁，轻量级锁和重量级锁。锁可以升级但不能降级。这样是为了提高获取锁和释放锁的效率。

  - 各个锁

    - 偏向锁：因为大多数情况下，锁不仅不存在线程的竞争，而且总是同一个线程多次获得，为了让线程获取锁的代价更低而引入了偏向锁，当同一个线程进入和退出同步块的时候不需要进行CAS操作来加锁和解锁，而是简单先取对象头的MarkWord看一下是否是指向当前线程的偏向锁，如果是，就是表示当前线程已经获取到了锁，如果没有，则需要检测一下MarkWord中的偏向锁的标记是都被设置为了1，如果没有设置，那么CAS竞争锁，如果设置了，则尝试将CAS的对象头偏向锁指向当前线程。

      偏向锁撤销：

      是一种等到竞争出现才释放的锁，所以当其他线程开始尝试竞争偏向锁的时候，持有偏向锁的代码才会释放锁，偏向锁的撤销，需要等待全局安全点（此时这个时间点没有正在执行的字节码），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否还活着，如果不处于活动状态，就把状态设置为无锁状态，如果活着，持有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁后者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

      偏向锁关闭：

      偏向锁在java6和7是默认启用的，但是在程序启用几秒钟之后才会激活，如果有必要可以使用JVM参数来关闭延迟。设置关闭之后，程序就会默认进入轻量级锁状态。

    - 轻量级锁

      加锁：在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并且将MarkWord复制进去，然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针，如果成功，那么当前线程获取锁，如果失败，那么表示其他线程竞争锁，当前线程便尝试自旋来获取锁。

      解锁：轻量级锁解锁的时候，会使用原子的CAS将存储锁记录的空间替换会到对象头，如果成功，那么表示没有竞争发生，如果失败，表示当前锁存在竞争，锁就会膨胀成为重量级锁。

  - synchronized可以保证什么

    ```
    有序性
    可见性
    原子性
    可重入性
    ```

  - 和Lock的比较

    1，synchronized是关键字，加锁解锁都由JVM帮忙做了，而lock是一个接口，他有很多实现。

    2，synchronized自动释放锁，lock需要我们自己调用

    3，synchronized是不可中断的，lock可以中断可以不中断

    4，lock 可以知道线程有没有拿到锁，而synchronized不行

    5，synchronized能锁方法和代码块，而lock只能锁代码块

    6，lock可以通过读锁来提高多线程读的效率，而synchronized不行

    7，synchronized是非公平锁，而lock，比如ReentrantLock可以设置公平性