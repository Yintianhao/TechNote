## Java基础

### JDK,JRE,JVM

JDK,java Development Kit，jdk包含了完整的JRE，即Java运行时环境，此外还包含了许多其他的工具包。          
JRE，普通用户只需要安装JRE来运行Java程序，而开发人员必须安装jdk来编程，调试程序。         
JVM，JVM负责将字节码转为特定的机器代码，jvm提供内存管理和垃圾回收和安全机制等，独立于操作系统。         
区别和联系：            
JDK用于开发，JRE用于运行Java程序。          
JDK和JRE都包含JVM           
JVM是Java编程语言的核心。           

### 字节码

Java引入虚拟机，即在机器和程序之间加入一层虚拟的机器，在任何操作系统上都提供程序运行的接口，编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器将虚拟机代码转换为特定系统的机器机器码执行，然后在特定机器上运行。            
流程：      
Java代码--编译器--JVM可执行的字节码--JVM--JVM解释器--机器码

### 构造方法

父类的方法中，私有和构造方法不能被重写，但是可以重载

### 重载和重写

重写，发生在父类和子类中，参数列表必须相同，返回值必须是父类对象中返回类型或者派生类。

重载，发生在同一个类中，方法名相同，参数类型不同，个数不同，顺序不同，只有返回类型不同不能称之为重载。

### 面向对象三个属性

- 封装

- 多态

  是程序定义中引用变量所指向的具体类型和通过该引用发出的方法调用在编程的时候并不确定，而是在程序运行期间才确定，即一个引用到底指向的是哪个实例对象，在运行期间才能决定。

- 继承

  Java不支持多继承，private，public，protected都不加表示包级可见，protected表示子类可见，子类的方法的访问级别不低于父类的访问级别，这是为了确保所用到父类的地方都能用子类实例来代替。

### 抽象类和接口

1，抽象类，abstract修饰，含有抽象方法的类一定是抽象类。抽象类和普通类最大的区别就是抽象类不能实例化，只能被继承，但是抽象类里可以有普通方法。

2，接口，interface修饰，是抽象类的延伸，Java8之前是一个完全抽象的类，之后支持默认的实现。不支持的化，维护成本比较高。接口成员默认是public static final的，抽象类没有这个限制。

3，抽象是对类的抽象，是一种模板设计，而接口实际上是对行为的抽象，是一种行为点规范。

### 基本类型和包装类型

byte(一个字节)，char(两个字节)，short(两个字节)，int(四个字节),float(四个字节),long(八个字节),double(八个字节),boolean(具体大小没有规定，编译器会将其转化为1/0)    

int -- Integer 等      
自动装箱和拆箱：      
装箱：基本类型-->包装类型    
拆箱：包装类型-->基本类型     

- 缓存池

  Integer.valueOf(123)和new Interger(123)的区别；      
  前者取缓存池，后者直接新建对象。    
  其他包装类型对应的缓存池：     
  Boolean: true false      
  Short -128->127     
  Char \u0000-->\u007F    

### 元注解

- @Target

说明注解所修饰的对象范围

- @Retention

定义该注解被保留的时间长短，SOURCE 源文件中有效，CLASS Class文件中有效，RUNTIME 运行时有效

- @Documented

用于描述其他类型的注解应该被作为被标注的程序成员的公共API

- @Inherited

描述某个被标注的类型是被继承的，如果@Inherited修饰的注解类型被用于一个class，那么这个注解将被用于该class的子类

### String类

String不可变，好处是：

1，不可变点变量的hash值不变，适合做HashMap的key。

2，String池的需要，只有String是不变的，才能使用String池。

3，安全性，String作为参数，String不可变性可以保证参数不可变。

4，线程安全，不可变性具有线程安全的特点，在多个线程中能安全使用。

### String，StringBuilder，StringBuffer

String不可变，其他两个可变，StringBuilder是线程不安全的，其他两个是线程安全的。

### static关键字

静态变量，意味着所有实例对象都共享它，通过类名可以直接访问，它在内存中只有一份。

对于静态方法，在类加载点时候就存在了，所以静态方法必须实现，不能是抽象的。

对于静态语句块，在类初始化的时候运行一次。

对于静态内部类，不需要先创建外部的实例对象就能创建自己的实例。

### 静态，非静态的初始化顺序

父类：静态变量，语句块

子类：静态变量，语句块

父类：普通变量，语句块

父类，构造函数

子类：普通变量，语句块

子类：构造函数

