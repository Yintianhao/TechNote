## 类加载

虚拟机把描述类的数据从class文件加载到内存，对数据进行校验，转换解析和初始化最终形成可以被JVM使用的Java类型的过程。

### 时机

遇到new，getstatic，putstatic，invokestatic这四个字节码指令的时候，如果类没有初始化，则对其初始化。（即new一个对象，读取或者设置一个静态变量，调用静态方法）        
使用反射对类进行反射调用的时候，若类没有初始化，则对其初始化。     
初始化一个类时，若父类没有初始化，那么对其父类初始化
虚拟机启动时，对main方法所在的类进行初始化
JDK1.7中，一个MethodHandle对象解析结果是对静态变量或者方法操作的句柄，且句柄对应的类没有初始化。

### 过程

- 加载

  1，通过类的全限定名，获取定义此类的二进制数据流，同时进行文件格式验证
  2，将字节流代表的静态存储结构转化为方法区内的运行时数据结构。
  3，在内存堆中生成一个代表该类的Class实例对象，作为方法区这个类的各种数据访问的入口。(方法区的作用)

  - 类全限定名的来源

    ```
    1，压缩包读取，jar、war
    2，其他文件动态生成：JSP动态生成Class
    3，从网络中获取二进制数据流：applet小程序
    4，运算时计算生成，反射动态代理。
    ```

  - 数组类和非数组类加载有区别

    ```
    数组类：new Class1[]，是JVM直接创建数组类，再由类加载器创建数组中的元素类。                 
    非数组类：由加载器加载完成，可用引导类加载器和用户自定义加载器。
    ```

- 验证

  - 1 ，文件格式验证

  ```
  验证字节流是否满足Class文件规范，如开头魔数是否为CAFEBABY，主次版本号是否在处理范围内。
  
  加载时机：加载开始时，文件验证就开始了，这一步骤的验证完成后，二进制数据流也进入方法区。形成待验证的类元数据信息，证明了加载和验证是交叉进行的。
  ```

  - 2，元数据验证

  ```
  对字节码的信息进行语义分析，确保符合java语法规范，如验证一个类的字段是否和父类产生矛盾，父类是否继承不被允许的类。
  ```

  - 3，字节码验证：

  ```
  对类的方法体进行校验分析
  ```

  - 4，符号引用验证

  ```
  校验内容：
  1，符号引用中通过字符串描述的全限定名是否能找到相应的类
  2，在指定类中是否存在符合方法的字段描述符，简单名称所描述的方法和字段。
  3，符号中引用的类，字段，方法的访问性是否可以被当前类访问。
  
  校验时机：解析阶段
  ```

- 准备

  1，为类的静态成员变量分配方法区内存          
  2，为静态成员变量初始化0值(如果是static final，那么复制ConstValue)

- 解析

  将常量池的中的符号引用替换为直接引用的过程。

- 初始化

  类加载器<clinit>

  1，静态代码块可以访问代码块之前的静态成员变量，无法访问之后的。
  2，clinit()中静态变量的赋值顺序是根据java代码中的顺序来的。
  3，父类clinit优于子类clinit

### 类加载器

一个类要在虚拟机中确定，就需要和它的类加载器一起确定，即判两个类是否相等，前提是他们的类加载器也要相同。

四种类加载器：

```
启动类加载器：负责加载JAVAHOME\lib下的class文件，
扩展类加载器：负责加载JAVAHOME\lib\ext下的class文件
应用程序加载器：classpath下的class文件
自定义：重写findClass，寻找加载类的二进制流->调用defineClass，将数据流定义为类->创建自定义类加载器，调用loadClass
```

双亲委派模型：

```
委派过程：如果一个类加载器收到了加载一个类的请求，则先将请求交给父类加载器加载，若父类加载失败，找不出加载的类，则抛ClassNotFoundException，则返回使用当前类加载器加载
作用：避免了多份同样的字节码的加载。确保加载所有的类的加载器具有唯一性，不会发生用户自定义加载器和引导类加载器都可以加载java.lang.Object的情况，防止恶意代码对JDK的破坏。
```

Class.forName和loadClass的区别：

loadClass加载的类处于加载阶段尚未被解析，forName加载的类已经完成了初始化。