## GC相关

- 新生代

  Eden，From survivor（s0），To survivor（s1）

  对象会优先在Eden区进行分配，当eden区不足的时候，虚拟机会发生一次MinorGC，如果仍然没有空间来存放，那么就用分配担保机制将这个对象移动到老年代中。

- 老年代

  大部分情况下，对象首先在Eden分配，在一次新生代垃圾回收之后，如果对象还活着，那么进入s0或者s1，然后对象的年龄会加1，直到年龄增加到15，默认15（可以通过-XX:MaxTenuringThreshold设置），就会晋升到老年代。经过一次GC，Eden和from会被清空，MinorGC会重复这样的过程，直到To区被占满，被占满之后，这些对象会被移动到老年代中。

  ```
  1，大对象会直接进入老年代，因为避免大对象分配的时候发现内存不足而触发分配担保机制而带来复制。
  2，长期存活的对象将进入老年代，和上面的过程一样，发生一次minorGC，年龄+1
  ```

- 永久代

### GC 分类

- 部分收集

  MinorGC，只针对新生代来收集。

  MajorGC，只针对老年代来收集。

  混合收集，MixedGC，对整个新生代和部分老年代进行垃圾收集。

- FullGC

  收集整个Java堆和方法区，发生在老年代写满

### 垃圾回收算法

- 标记清除

  从根开始扫描，判断并标记可回收对象，对堆内存进行线性扫描，清除所有被标记的对象           
  缺点：产生大量碎片化空间，标记清除，两趟扫描，效率低下。      

- 标记复制

  将内存大小分为两个相等部分，同一时间只从一块移动到另外一块，A内存进行标记后，把A中的存活对象移动到B，清除A。          
  解决问题：避免了碎片化空间，简单高效。       
  存在的问题：浪费一半空间，存活率高的时候，效率低下。  

- 标记整理

  将所有可回收对象打上标记，让所有存活对象向前移动一段内存，覆盖可回收的区域，将最后一个可存活的边界之外的对象全部清除。         
  优点：解决了碎片化的问题，不需要把内存拆分成两半，提高利用率，是一种老年代算法，因为老年代对象寿命长，GC会友大量存活，所以适合使用标记整理。        

### 垃圾回收器

- 新生代 

  - Serial，开启一个GC线程来进行垃圾回收，回收时停止一切用户线程，易造成其他图形界面出现卡顿。不与其他线程交互，避免了开销，获得了单线程的最高利用率，适用于单CPU下client模式的虚拟机
  - ParNew，Serial的多线程版本，同样需要停止一切用户线程，开启多个GC线程并行收集垃圾，默认线程数等于CPU核心数。多线程提高了垃圾回收的效率，单CPU环境下需要上下文切换，性能不如Serial，适合Server模式，另一方面。它也是除了Serial唯一能和CMS配合的收集器
  - ParallelScavenge，过程和ParNew一样，特点是更关注吞吐量，吞吐量=用户线程运行时间/(运行时间+垃圾回收时间)。

- 老年代

  - Serial Old

  - Parallel Old

  - CMS Concurrent Mark Swap

    ```
    步骤：      
    1，初始标记，暂停全部线程STW，单线程标记与GCRoot直接关联的对象，过程很短。     
    2，并发标记，进行GCRoot的追踪，标记所有关联对象，用户和GC线程并发执行。            
    3，重新标记，暂停全部线程，重新标记并发阶段因为用户线程执行而使得标记产生变化的对象。     
    4，并发清除，开启用户线程，同时GC线程进行垃圾清除，并发。                
    特点：获得最短的用户线程停顿时间。标记清除算法                          
    存在问题：采用标记清除，产生大量碎片。CMS对CPU敏感，若核心数比较低，则会占用很多资源，造成用户应用速度变慢。无法处理浮动垃圾，最终并发清除时，用户线程仍然在运行，
    不可避免产生垃圾，正因此如此，不能等待内存快满再GC ，而要预留一块空间给用户装对象，若CMS执行还未完成时，预留空间不足，就会造成ConcurrentModelFailure从而开启另一次GC 
    ```

- G1

  ```
  步骤：  
  1，初始标记，暂停全部线程，单线程标记和GCRoot直接关联的对象。
  2，并发标记，然后与用户线程并发进行，从GCRoot找出存活对象，将因为用户线程发生变化的对象记录日志下来。
  3，最中标记，暂停全部线程，然后将日志记录的对象去除放在Remembered Set中。
  4，筛选回收，暂停全部线程，对每一个Region，通过对回收的价值和成本进行排序，再根据用户所期望的时间，制定回收计划，有限时间回收有限个region ，GC并行。                     
  特点：并发和并行，分代收集，空间整合（标记整理算法）可预测停顿，每一个区域都有RememberedSet用来记录该Region的对象所引用的其他对象所在的Region区域，可达性分析时将这些区域加入GCRoot扫描，避免了整个堆的扫描。          
  后台维护了优先队列，每次根据用户允许的回收时间，回收最有价值的Region。  
  ```

  

###  调优待看

