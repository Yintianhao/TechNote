## Redis
### Redis单线程模型详解
Redis基于Reactor模式开发自己的事件处理模型，这一套事件处理模型对应的是文件事件处理器。
- [ ] Redis怎样监听大量的客户端连接呢？
Redis通过IO多路复用程序来监听大量的客户端连接，会把感兴趣的事件和类型注册到内核中并监听每个事件是否发生。这样可以避免多余的进程创建来监听这些连接，降低资源消耗，和NIO中是选择器是类似的。
- [ ] 文件事件处理器
1，多个socket（客户端连接）
2，IO多路复用程序（支持多个客户端连接的关键）
3，文件事件分派器（将socket和相应的事件处理器关联在一起）
4，事件处理器（连接应答处理器，命令请求处理器，命令回复处理器）
### 为什么Redis不使用多线程
其实Redis已经支持了多线程，但是只是用在删除一些大的键值对的删除命令的时候，来进行异步处理
之所以不使用是因为：
1，单线程更加容易维护。
2，Redis的性能瓶颈不在CPU，而是内存和网络。
3，多线程也会存在死锁，线程上下文切换等问题，影响性能。
### 过期数据的删除策略
1，惰性删除，只会在取出key的时候才对数据进行过期检查，对CPU比较友好，但是有可能会造成很多key没有被删除
2，定期删除，每隔一段时间抽取一批key删除过期的key，并且，redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU事件的影响。
### Redis内存淘汰机制
1，volatile-lru，从已设置过期时间的数据集中挑选出最近最少使用的来进行淘汰
2，volatile-ttl，从已经设置过期时间的数据集中挑选出过期的数据淘汰
3，volatile- random，从已设置过期时间的数据集里任意选择数据淘汰
4，allkeys-lru，当内存不足以容纳新的数据的时候，在键空间里，移除最近最少使用的key
5，no-evition，当内存不足的时候，新的写入操作会报错

### Redis持久化
- [ ] RDB
通过创建快照来获得存储在内存里的数据在某一个时间点的副本，Redis创建快找之后，可以对快找进行备份，可以将快照复制到其他服务器从而创建相同服务器副本，还可以将快照留在原地，以便于重启服务器的时候使用。
- [ ] AOF
与快照序列化相比，AOF序列化的实时性更好，因此成为主流的持久化方案，默认不会开启。
开启AOF之后，Redis会每执行一条更改Redis中的数据的命令，就会将命令写到硬盘中的AOF文件，AOF文件的保存位置和RDB的位置相同。
appendfsync always 每次有数据修改发生的时候都会写入AOF文件
appendfsync everysec 每一秒钟同步一次
appenffsync no 让操作系统决定何时同步
- [ ] Redis4.0对于持久化已经支持RDB和AOF混合持久化，AOF重写的时候将RDB的内容写到AOF文件开头，这样做的好处就是可以结合RDB和AOF的优点，快速加载的同时避免丢失更多的数据，但是缺点肯定也是有的，那就是AOF中的RDB部分，不再是AOF格式，可读性不好。
### 缓存穿透
大量请求的key不在缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。
- [ ] 解决办法
  最基本的办法就是做好参数校验，一些不合法的参数请求直接抛出异常返回给客户端。
  1，缓存无效key，如果数据库和缓存都查不到key就把这个key的数据写到一个redis中设置过期时间，但是很明显这个不能根本上解决问题，如果有人恶意生成了很多key，就不行了。
  2，布隆过滤器
  可以方便地判断给定数据是否在海量数据中。具体是把所有可能存在的请求之放在布隆过滤器中，用户请求过来的时候，先判断用户请求的值是否在过滤器中，不存在的就直接返回错误信息给客户端，存在继续查询。 

  但是布隆过滤器会存在小概率误判的可能，布隆过滤器判断某个元素不在，那一定不在。

- 缓存雪崩

缓存在同一个时间大面积失效，后面的请求直接落到数据库的情况，造成数据库短时间内承受大量请求。

1，针对Redis服务不可用，搭建Redis集群，增加redis可用性

2，限流，避免同时大量的请求。

针对热点数据缓存失效的情况：

1，设置不同的失效时间，比如随机设置缓存的失效时间。

2，缓存永不失效。

### 保持缓存和数据库的一致性

旁路缓存模式：

写请求：更新DB，直接删除Cache。

如果更新数据库成功，而删除缓存这一步失败的情况的话，有：

1，缓存失效时间变短。

2，增加cache更新重试机制，如果cache服务当前不可用导致缓存删除失败，就隔一段时间进行重试，重试次数自己定，如果多次重试还是失败的话，可以把更新失败的key放在队列中，等待服务可用，再将key删除。